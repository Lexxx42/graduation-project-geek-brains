# Поиск элементов с помощью Selenium WebDriver

## Поиск элементов с помощью Selenium

Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих искать по атрибутам
элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод find_element,
который принимает два аргумента - тип локатора и значение локатора. Существуют следующие методы поиска элементов:

+ `find_element(By.ID, value)` - поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем
  элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он
  наиболее стабильный;
+ `find_element(By.CSS_SELECTOR, value)` - поиск элемента с помощью правил на основе CSS. Это универсальный метод
  поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если
  find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот
  метод в ваших тестах;
+ `find_element(By.XPATH, value)` - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск
  элементов;
+ `find_element(By.NAME, value)` - поиск по атрибуту name элемента;
+ `find_element(By.TAG_NAME, value)` - поиск элемента по названию тега элемента;
+ `find_element(By.CLASS_NAME, value)` - поиск по значению атрибута class;
+ `find_element(By.LINK_TEXT, value)` - поиск ссылки на странице по полному совпадению;
+ `find_element(By.PARTIAL_LINK_TEXT, value)` - поиск ссылки на странице, если текст селектора совпадает с любой частью
  текста ссылки.

Например, мы хотим найти кнопку со значением id="submit_button":

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit")
```

Обратите внимание, что мы импортировали класс By, который содержит все возможные локаторы.

Если страница у вас загрузилась, но дальше ничего не происходит, вернитесь обратно в консоль, в которой вы запускали ваш
скрипт. Скорее всего, вы увидите там ошибку NoSuchElementException. Она будет выглядеть следующим образом:

```
selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element:
{"method":"id","selector":"submit"}
```

Ошибка очевидна: мы неправильно указали локатор — значит, кнопки с таким id на странице нет.

Исправим локатор, чтобы наш код проходил без ошибок:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")
```

### Поиск нескольких элементов

Вы можете столкнуться с ситуацией, когда на странице будет несколько элементов, подходящих под заданные вами параметры
поиска. В этом случае WebDriver вернет вам только первый элемент, который встретит во время поиска по HTML. Если вам
нужен не первый, а второй или следующие элементы, вам нужно либо задать более точный селектор для поиска, либо
использовать методы `find_elements`, которые мы рассмотрим чуть позже.

## Работа с браузером в Selenium

Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается после выполнения
кода. Поэтому обратите внимание на то, что необходимо явно закрывать окно браузера в нашем коде при помощи команды
`browser.quit()`. Каждый раз при открытии браузера `browser = webdriver.Chrome()` в системе создается процесс, который
останется висеть, если вы вручную закроете окно браузера. Чтобы не остаться без оперативной памяти после запуска
нескольких скриптов, всегда добавляйте к своим скриптам команду закрытия:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()
```

Важно еще пояснить разницу между двумя командами: `browser.close()` и `browser.quit()`.
Какая между ними разница, ведь на первый взгляд обе они осуществляют одно и то же?

На самом деле, `browser.close()` закрывает текущее окно браузера.
Это значит, что если ваш скрипт вызвал всплывающее окно,
или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно, а все остальные останутся висеть.
В свою очередь `browser.quit()` закрывает все окна, вкладки,
и процессы вебдрайвера, запущенные во время тестовой сессии.

Подробнее можно посмотреть
здесь:
[Difference between webdriver.Dispose(), .Close() and .Quit()](https://stackoverflow.com/questions/15067107/difference-between-webdriver-dispose-close-and-quit).

Будьте внимательны с этими методами и, в общем случае, всегда используйте `browser.quit()`.

Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше?

Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, проще всего использовать
конструкцию try/finally:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()
```

## Поиск всех необходимых элементов с помощью find_elements

Мы уже упоминали, что метод find_element возвращает только первый из всех элементов, которые подходят под условия
поиска. Иногда возникает ситуация, когда у нас есть несколько одинаковых по сути объектов на странице, например, иконки
товаров в корзине интернет-магазина. В тесте нам нужно проверить, что отображаются все выбранные для покупки товары. Для
этого существует метод find_elements, которые в отличие от find_element вернёт список всех найденных элементов по
заданному условию. Проверив длину списка, мы можем удостовериться, что в корзине отобразилось правильное количество
товаров. Пример кода (код приведен только для примера, сайта fake-shop.com скорее всего не существует):

```python
# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера
browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# открываем страницу второго товара
browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements(By.CSS_SELECTOR, ".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2
```

**!Важно.**
Обратите внимание на важную разницу в результатах, которые возвращают методы `find_element` и `find_elements`.
Если первый метод не смог найти элемент на странице, то он вызовет ошибку NoSuchElementException, которая прервёт
выполнение вашего кода.
Второй же метод всегда возвращает валидный результат: если ничего не было найдено, то он вернёт пустой
список и ваша программа перейдет к выполнению следующего шага в коде.
