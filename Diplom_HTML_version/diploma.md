<!-- Output copied to clipboard! -->

<!-----

You have some errors, warnings, or alerts. If you are using reckless mode, turn it off to see inline alerts.
* ERRORs: 0
* WARNINGs: 0
* ALERTS: 16

Conversion time: 24.578 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β34
* Fri May 26 2023 01:49:38 GMT-0700 (PDT)
* Source doc: Автоматизация тестирования UI с помощью Selenium и Pytest
* Tables are currently converted to HTML tables.
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 0; ALERTS: 16.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>


Geekbrains

Факультет тестирования ПО

<h2>Автоматизация тестирования UI с использованием Selenium и Pytest</h2>

**Дипломный проект**

студента 1 года обучения

специальности “Тестирование ПО”

Конюхов А.С.

Руководитель

Шафигуллин И.К.

Радужный

2023

**Дипломный проект “Автоматизация тестирования UI с использованием Selenium и Pytest”**

**Содержание**

[TOC]

<h2>Введение</h2>


<p>Актуальность

Автоматизация проникает во все сферы деятельности человека, избавляет от рутин и тестирование ПО не исключение.
Автоматизация позволяет разгрузить тестировщика от рутинных проверок во время ретеста и регрессивного тестирования. А
также для повышения качества разрабатываемого продукта путем встраивания в цикл непрерывной интеграции и непрерывной
доставки. Актуальность темы дипломной работы связана со значительным распространением автоматизации тестирования и языка
программирования Python и заключается в необходимости разработки рекомендаций по изучению данного направления для
начинающих и практикующих специалистов по обеспечению качества.

<p>Цели и задачи

Цель дипломной работы является разработка дорожной карты развития начинающего специалиста по обеспечению качества
разработки ПО. Познакомить с инструментами и сформировать компетенции для успешного развития в направлении автоматизации
тестирования на языке программирования Python.

Задачами дипломной работы в связи с указанной целью являются:

* изучить основные понятия теории тестирования;
* исследовать наиболее распространенные web-технологии;
* изучить систему контроля версий Git;
* изучить базовые возможности языка программирования Python;
* изучить основные возможности и методы Selenium;
* исследовать расширение возможностей тестирования с помощью фреймворков;
* раскрыть необходимость использования паттерна Page Object Model;
* изучить различные методы формирования отчетов о тестировании.

<p>Объект и предмет исследования

Объектом дипломной работы является изучение начинающим специалистом автоматизации на языке Python для тестирования
пользовательского интерфейса сайтов, и способы ускорения профессионального развития в данном направлении.

Предметом дипломной работы являются открытые источники в сети интернет, книги и курсы посвященные тестированию ПО.

<p>Научная и практическая значимость

Научная новизна заключается в нахождении нового подхода к обучению специалистов в направлении автоматизации на языке
программирования Python.

Практическая значимость заключается в снижении времени, необходимого для получения навыков, необходимых для
использования в автоматизации тестирования UI web-приложений.

<p>Инструменты и технологии

В дипломном проекте будут использованы следующие инструменты: DevTools, PyCharm, Python, Selenium WebDriver, Pytest,
Allure.

Будут использованы следующие технологии: ChromeDriver, geckodriver, pytest-html, pytest-rerunfailures, allure-pytest,
Page Object Model.

<p>Рекомендации по изучению

Дипломный проект представляет из себя курс по освоению (или расширению уже имеющихся) знаний в области автоматизации
тестирования на языке программирования Python.

Рекомендуется проходить курс последовательно и самостоятельно изучать дополнительные материалы. Ссылки на некоторые
материалы будут приведены по ходу курса, но рекомендуется проводить самостоятельную работу по поиску актуальной
информации.

<h2>Глава 1. Теория тестирования</h2>

<h3>1.1 Что такое тестирование?</h3>

<h4>1.1.1 Определение тестирования ПО</h4>

Чтобы погрузиться в автоматизацию тестирования необходимо разобраться с тем что такое тестирование, для чего оно
необходимо и как оно осуществляется.

Есть несколько разных трактовок о том, чем же является тестирование ПО, рассмотрим некоторые из них и вычленим общие
черты тестирования.

Тестирование программного обеспечения - процесс исследования, испытания программного продукта, имеющий своей целью
проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных
определенным образом.[^1]

Святослав Куликов дает такое определение тестирования ПО в своей книге «Тестирование программного обеспечения. Базовый
курс.»:

Тестирование программного обеспечения — процесс анализа программного средства и сопутствующей документации с целью
выявления дефектов и повышения качества продукта.[^2]

Международный совет по тестированию программного обеспечения (ISTQB, International Software Testing Qualifications
Board) содержит только определение тестирования:

The process consisting of all lifecycle activities, both static and dynamic, concerned with planning, preparation and
evaluation of a component or system and related work products to determine that they satisfy specified requirements, to
demonstrate that they are fit for purpose and to detect defects.[^3]

Итак мы узнали, что тестирование - это поиск дефектов (багов) с целью повышения качества продукта. Как же эти баги
обнаруживают?

1. Используем источники ожидаемого поведения системы (тестовые оракулы) для понимания как должна работать система.

2. Производим манипуляции с системой, чтобы она проявила свое истинное поведение.

3. Сравниваем ожидаемый результат с фактическим.

<h4>1.1.2 Кто такой тестировщик?</h4>

Тестировщик - специалист заботящийся о качестве системы в виде обнаружения дефектов до того, как их обнаружат
пользователи системы.

Тестирование служит для повышения качества системы через обнаружение дефектов и их устранение.

Вы наверное слышали такие термины как Tester, QC, QA. Их довольно часто путают между собой или смешивают, поэтому
давайте разберемся в терминологии.

* Тестирование — это уже непосредственно процесс проверки результатов работы на соответствие установленным требованиям.
* QC — Контроль качества продукта — анализ результатов тестирования и качества новых версий выпускаемого продукта.
* QA — Обеспечение качества продукта — изучение возможностей по изменению и улучшению процесса разработки, улучшению
  коммуникаций в команде, где тестирование является только одним из аспектов обеспечения качества.

Без понимания основ теории тестирования невозможно стать хорошим автоматизатором тестирования. Она необходима для
понимания важности работы тестировщика и его участии в развитии продукта и работе в команде.

Заострим внимание ещё на одном важном аспекте теории тестирования - принципах тестирования.

Выделяют семь принципов тестирования:

1. Исчерпывающее тестирование невозможно (Exhaustive testing is impossible).
2. Тестирование демонстрирует наличие дефектов, а не их отсутствие (Testing shows presence of defects).
3. Тестирование зависит от контекста (Testing is context depending).
4. Раннее тестирование (Early testing).
5. Скопление или кластеризация дефектов (Defects clustering).
6. Парадокс пестицида (Pesticide paradox).
7. Заблуждение об отсутствии ошибок (Absence-of-errors fallacy).

Подробнее о принципах тестирования вы можете ознакомиться в статьях на Habr “Фундаментальная теория тестирования[^4]” и
“Принципы тестирования: нас 7[^5]”.

<h3>1.2 Классификация тестирования</h3>

Существует много различных классификаций тестирования и каждый автор обладает своим мнением по классификации
тестирования. Поэтому говоря о классификации тестирования лучше уточнить согласно какому источнику от вас хотят услышать
ответ.

Проанализировав различные источники можно разделить классификацию тестирования по различным способам классифицировать
само тестирование.

По уровням тестирования: модульное, интеграционное, системное, End-to-End, приёмочное.

По принципу работы с приложением: позитивное, негативное.

По доступности: черный ящик, серый ящик, белый ящик.

По запуску кода: статическое, динамическое.

По степени автоматизации: ручное, полуавтоматизированное, автоматизированное.

По зависимости от целей тестирования: функциональное, нефункциональное.

В свою очередь каждая классификация содержит в себе входящие в себя подкатегории, которые на стыке друг с другом
образуют новые виды тестирования. Например, на пересечении конфигурационного и UI тестирования возникает тестирование
совместимости, направленное на проверку того, что интерфейс корректно работает при различных конфигурациях ПО и
платформ. А на срезе тестирования UI и безопасности возникает тестирование локализации и интернационализации.

<h3>1.3. Тестирование UI</h3>

Важно понимать на каких аспектах работы ПО сосредоточено UI тестирование для успешного изучения автоматизации UI
тестирования.

UI тестирование, также известное как тестирование пользовательского интерфейса, представляет собой тип тестирования
программного обеспечения, которое фокусируется на графическом пользовательском интерфейсе приложения. Тестирование UI
проводится, чтобы удостовериться, что интерфейс приложения работает должным образом, а также что им легко пользоваться и
ориентироваться.

Тестирование пользовательского интерфейса важно для выявления проблем, таких как неработающие ссылки, неправильное
форматирование или некорректное поведение при взаимодействии с интерфейсом, работу элементов взаимодействия с
пользователем таких как кнопки, поля ввода, модальные окна, выпадающие списки, меню и прочее.

Несколько примеров UI тестирования:

1. Функциональное тестирование. Этот тип тестирования гарантирует, что компоненты пользовательского интерфейса, такие
   как кнопки и формы, работают должным образом. Например, если пользователь нажимает кнопку, UI должен выполнить
   ожидаемое действие.

2. Юзабилити-тестирование. Этот тип тестирования гарантирует, что пользовательский интерфейс прост в использовании и
   навигации. Например, проверяется подходящий размер шрифта и визуально привлекательная цветовая схема.

3. Тестирование производительности. Этот тип тестирования гарантирует, что пользовательский интерфейс отзывчив и хорошо
   работает в различных условиях. Например, проверяется насколько быстро загружается интерфейс и как он работает при
   одновременном доступе к нему нескольких пользователей.

4. Тестирование совместимости. Этот тип тестирования гарантирует, что пользовательский интерфейс хорошо работает на
   различных устройствах и платформах. Например, проверяется правильность отображения приложения на экранах разных
   размеров и разрешений, работу приложения в разных браузерах.

5. Тестирование доступности. Этот тип тестирования гарантирует, что пользовательский интерфейс доступен для
   пользователей с ограниченными возможностями. Например, он проверяет, можно ли использовать приложение с программой
   чтения с экрана и что используемые цвета доступны пользователям с цветовой слепотой.

Это всего лишь несколько примеров типов тестирования пользовательского интерфейса, которые можно выполнить, чтобы
убедиться, что пользовательский интерфейс приложения работает должным образом.

Наибольшее распространение получило именно автоматизированное функциональное тестирование пользовательского интерфейса,
которое мы и будем изучать на стеке Selenium + Pytest.

Подведём небольшой итог этой главы: без знания основ тестирования невозможно стать хорошим автоматизатором тестирования.
Требуется гораздо более глубокое понимание того как, когда и зачем производится определённый вид тестирования. Только в
сочетании знания теории тестирования и навыков программирования возможно добиться высоких показателей качества продукта,
который вы разрабатываете.

<h2>Глава 2. Базовые знания web-технологий</h2>

<h3>2.1 Основы HTML</h3>

<h4>2.1.1 Что такое HTML?</h4>

HTML — это не язык программирования, а язык разметки, используемый для структурирования и представления веб-страниц и их
содержимого. Он позволяет организовывать текст в абзацы, создавать маркированные списки, вставлять изображения и
отображать данные в таблицах. Понимание основ HTML и его особенностей имеет важное значение для любого тестировщика. Но
для автоматизации тестирования является неотъемлемой часть знаний.

HTML использует теги, которые представляют собой метки, используемые для разметки и классификации информации, что
упрощает для браузеров интерпретацию и форматирование контента на веб-сайте. Проще говоря, теги служат ключевыми
словами, которые указывают браузеру, как обрабатывать и отображать содержимое сайта.

<h4>2.1.2 HTML элемент</h4>

Давайте рассмотрим структуру HTML элемента.



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")

Рисунок 1. HTML элемент.

Главными частями нашего элемента являются:

1. Открывающий тег (Opening tag): Состоит из имени элемента (в данном случае, "p"), заключённого в открывающие и
   закрывающие угловые скобки. Открывающий тег указывает, где элемент начинается или начинает действовать, в данном
   случае — где начинается абзац.
2. Закрывающий тег (Closing tag): Это то же самое, что и открывающий тег, за исключением того, что он включает в себя
   косую черту перед именем элемента. Закрывающий элемент указывает, где элемент заканчивается, в данном случае — где
   заканчивается абзац. Отсутствие закрывающего тега является одной из наиболее распространённых ошибок начинающих и
   может приводить к странным результатам.
3. Контент (Content): Это контент элемента, который в данном случае является просто текстом.
4. Элемент(Element): Открывающий тег, закрывающий тег и контент вместе составляют элемент.[^6]
   Элементы могут иметь различные атрибуты, например класс:

<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")

Рисунок 2. Атрибут элемента.

Атрибуты предоставляют дополнительную информацию об элементе, которая не предназначена для отображения как часть самого
содержимого. В этом примере “class” — это имя атрибута, а “editor-note” — это значение атрибута. Атрибут “class”
позволяет присвоить элементу описательное имя, которое впоследствии можно использовать для ссылки на элемент в целях
стилизации или других функций.

Атрибуты часто используются для поиска элементов на странице, поэтому необходимо обратить на них внимание при изучении
HTML.

<h3>2.2 Основы CSS</h3>

<h4>2.2.1 Так что же такое CSS?</h4>

CSS (Cascading Style Sheets) — это код, используемый для настройки внешнего вида вашей веб-страницы. Понимание основ CSS
позволяет управлять такими аспектами, как цвет текста, расположение контента на экране и добавление фоновых изображений
и цветов. Для автоматизации тестирования необходимо знать как меняются свойства отображения элемента, такие как цвет,
размер и активное состояние.

Подобно HTML, CSS считается не языком программирования, а скорее языком таблиц стилей. Его цель — выборочное применение
стилей к определенным элементам в документах HTML.

<h4>2.2.2 Анатомия набора правил CSS</h4>

Давайте посмотрим на CSS более подробно:



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.png "image_tooltip")

Рисунок 3. Набор правил CSS.

Вся структура называется набором правил (но зачастую для краткости "правило"). Отметим также имена отдельных частей:

Селектор (Selector)

Имя HTML-элемента в начале набора правил. Он выбирает элемент(ы) для применения стиля (в данном случае, элементы p ).
Для стилизации другого элемента, просто измените селектор.

Объявление (Declaration)

Единственное правило, например color: red; указывает, какие из свойств элемента вы хотите стилизовать.

Свойства (Properties)

Способы, которыми вы можете стилизовать определённый HTML-элемент (в данном случае, color является свойством для
элементов [<p>](https://developer.mozilla.org/ru/docs/Web/HTML/Element/p)). В CSS вы выбираете, какие свойства вы хотите
затронуть в вашем правиле.

Значение свойства (Property value)

Справа от свойства, после двоеточия, у нас есть значение свойства, которое выбирает одно из множества возможных
признаков для данного свойства (существует множество значений color, помимо red).[^7]

<h3>2.3 Основы JavaScript</h3>

JavaScript — это язык программирования, который повышает интерактивность вашего веб-сайта. Он включает различные
функции, такие как интерактивные игры, отклики на нажатие кнопок или ввод данных в формы, динамический стиль и анимацию.

Вы можете ознакомиться с синтаксисом языка самостоятельно. Здесь же мы поговорим о наиболее часто встречаемых элементах
взаимодействиях: alert, confirm и prompt.

Alert - функция, которая показывает сообщение и ждёт, пока пользователь нажмёт кнопку “ОК”.

Например:

“alert("Привет");”



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.png "image_tooltip")

Рисунок 4. Alert JS.

Окно, появляющееся поверх элементов интерфейса, называется модальным. Пользователь не сможет взаимодействовать с
интерфейсом, пока не закроет модальное окно. В случае alert это нажатие на кнопку “OK”.

Код “let test = prompt("Test");“ отобразит модальное окно с полем ввода текста и кнопки “OK”, “Cancel”.



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image5.png "image_tooltip")

Рисунок 5. Prompt JS.

Функция confirm отображает окно с текстом вопроса и двумя кнопками: “OK”, “Cancel”. Результат - истина, если
пользователь выбрал “OK” и ложь в противном случае.

Например:

“let right = confirm("Ты всегда прав?");“



<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image6.png "image_tooltip")

Рисунок 6. Confirm JS.

В автоматизации тестирования Java Script часто используется как для тестирования UI, так и для тестирования баз данных и
API. Для автоматизации тестирования на Python вам понадобится базовое знание синтаксиса, так как некоторые вещи, чтобы
сэкономить время и не писать самостоятельно, мы используем из уже реализованных методов браузера. А они в свою очередь
реализованы на языке Java Script.

Подводя итог под знакомством с web-технологиями, которые сейчас активно используются для взаимодействия приложений с
пользователями, нужно отметить, что знание основ этих технологий позволяет эффективно производить тестирование
пользовательского интерфейса.

<h2>Глава 3. Знакомство с системой контроля версий Git</h2>

<h3>3.1 Что такое система контроля версий?</h3>

Система контроля версий — это программное обеспечение, которое позволяет хранить историю изменений в любом документе или
файле. Таким образом, вы можете легко просматривать и откатывать изменения, сделанные каким-либо участником проекта. Это
очень полезно, когда необходимо восстановить старую версию документа или сравнить две разные версии файла. Кроме того,
она позволяет отслеживать, кто и что изменил в документе или файле и помогает избежать конфликтов при одновременном
редактировании одного и того же файла.

Система контроля версий Git является распределенной, она используется для отслеживания изменений в файлах и директориях
проекта. Позволяет разработчикам контролировать и отслеживать изменения в проекте.

Чтобы работать с Git, необходимо инициализировать репозиторий в папке с проектом. После этого можно добавлять изменения
в репозиторий, создавая различные версии проекта. Можно также просматривать историю изменений и откатываться к любой
предыдущей версии. Также можно объединять работы различных разработчиков в один проект.

Я рекомендую начать изучение Git в игровой форме на сайте LearnGitBranching[^8], которое позволит вам изучить все
основные возможности и команды.

Большинство современных сред разработки поддерживают интуитивно понятный интерфейс для работы с системой контроля версий
Git и вам не надо знать наизусть все команды.

<h3>3.2. Файл README.md и разметка Markdown</h3>

Большинство open source проектов размещаются в GitHub и я рекомендую поступать также. Это не только даёт вам возможность
поделиться кодом с коллегами, но и работать совместно над проектом со специалистами из разных стран.

Стоит заострить внимание на аспекте README.md файла, который создаётся для каждого репозитория. Некоторые разработчики
пренебрегают созданием этого файла потому что не осознают до конца всей важности его наличия и влияния на сообщество.

README.md — это файл в репозитории GitHub, который служит файлом документации для репозитория. Он написан в формате
Markdown и предоставляет информацию о назначении репозитория, инструкции по установке, примеры использования и любую
другую информацию касательно содержимого проекта, например, примеры оформления баг-репортов или способы связаться с
автором для совместной разработки.

Файл README.md важен, потому что он помогает пользователям понять назначение и использование репозитория. Он также
предоставляет важную информацию, которая может помочь пользователям быстро и легко начать работу с репозиторием. Кроме
того, наличие хорошо написанного файла README.md может помочь привлечь участников в репозиторий и улучшить совместную
работу.

Часто вам потребуется читать и составлять подобные файлы, а также поддерживать их в актуальном состоянии. Поэтому важно
понимать, что должен содержать такой файл.

* Название: название вашего проекта или репозитория.
* Описание: краткое описание того, что делает ваш проект или репозиторий.
* Оглавление: список разделов в вашем файле README.md, если файл получился объёмным.
* Установка: инструкции по установке и настройке вашего проекта или репозитория.
* Использование: инструкции по использованию вашего проекта или репозитория.
* Участие: рекомендации о том, как внести свой вклад в ваш проект или репозиторий (опционально).
* Лицензия: информация о лицензии вашего проекта или репозитория.

Вы можете использовать синтаксис Markdown для форматирования контента и добавления заголовков, списков, изображений,
ссылок и других элементов.

Я перевел на русский язык удобную и информативную инструкцию по применению разметки Markdown[^9] с оригинальной Markdown
Cheatsheet by Adam Pritchard[^10] специально для тех, кому комфортнее читать актуальную документацию на родном языке.
Обязательно советую ознакомиться с ней или другими источниками.

Отметим, что автоматизация тестирования тесно связана с разработкой, поскольку является продуктом в продукте (ваш
тестовый фреймворк можно считать полноценным приложением). Поэтому без уверенного знания системы контроля версий
работать практически невозможно. А без надлежащего оформления сопутствующей документации проекта вы уже через месяц
забудете какие команды нужно использовать, чтобы получить необходимые результаты. Кроме того, отсутствие актуальной
документации не только приведёт к трате времени на объяснение того как работает ваш проект, но и в целом ухудшает
потенциальное качество проекта.

<h2>Глава 4. Основы Python</h2>

<h3>4.1 Знакомство с языком программирования Python</h3>

Программирование - это, по сути, процесс предоставления компьютеру инструкций для выполнения конкретной задачи. Для
этого нам нужно использовать язык программирования, который, по сути, представляет собой способ общения с компьютером
таким образом, чтобы он мог его понять.

Python - популярный язык программирования, известный своей простотой в изучении и использовании. Некоторые из основных
концепций программирования, применимых к Python, включают:

1. Синтаксис. Синтаксис языка программирования относится к правилам и соглашениям по написанию кода на этом языке. В
   Python, например, мы используем отступы для обозначения блоков кода, и мы используем определенные ключевые слова,
   такие как “if”, “else” и “while”, чтобы управлять потоком программы.
2. Типы и структуры данных. В Python мы можем работать с различными типами данных, включая числа, строки и списки. Мы
   также можем использовать структуры данных, такие как словари и множества, для организации данных и управления ими.
3. Структуры управления и ветвления. Структуры управления используются для управления потоком программы. В Python мы
   можем использовать операторы “if” для выполнения определенного кода, только если выполняется определенное условие,
   циклы “while” для повторения блока кода, пока определенное условие выполняется, и циклы “for” для повторения
   последовательности элементов.
4. Функции. Функции — это повторно используемые блоки кода, которые выполняют определенную задачу. В Python мы можем
   определить наши собственные функции с помощью ключевого слова “def”, а также можем использовать встроенные функции,
   такие как “print” и “len”.
5. Объектно-ориентированное программирование. Объектно-ориентированное программирование — это парадигма
   программирования, в которой особое внимание уделяется использованию объектов для представления данных и поведения. В
   Python мы можем определять наши собственные классы и объекты, которые позволяют нам организовывать наш код и
   создавать более сложные программы.

Это всего лишь несколько основных концепций программирования, применимых к Python.

Базовый синтаксис языка программирования Python достаточно прост и рекомендуется самостоятельно его изучить.

<h3>4.2 Базовые принципы ООП</h3>

Важным элементом для автоматизатора тестирования на любом языке программирования является понимание
объектно-ориентированной парадигмы, которая сейчас очень распространена в промышленной разработке.

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов,
которые могут содержать данные (атрибуты) и функции (методы), работающие с этими данными. ООП — это мощная парадигма
программирования, которую можно использовать для создания более модульного, повторно используемого и поддерживаемого
кода.

Однако количество кода растёт по экспоненте с количеством классов, которые вы внедряете по мере разработки.

Существует четыре основных принципа ООП:

1. Инкапсуляция. Относится к практике сокрытия внутренних деталей объекта от внешнего мира и раскрытия только
   общедоступного интерфейса, который можно использовать для взаимодействия с объектом. Это помогает защитить
   целостность объекта и упрощает поддержку и изменение кода с течением времени.
2. Абстракция. Относится к практике представления сложных систем или понятий с использованием более простых и общих
   понятий. Абстракция позволяет нам сосредоточиться на основных характеристиках объекта и игнорировать детали, которые
   не имеют отношения к нашей текущей задаче.
3. Наследование. Относится к практике создания новых классов, которые наследуют атрибуты и методы существующих классов.
   Наследование позволяет нам повторно использовать код и создавать более специализированные классы, основанные на
   функциональности более общих классов.
4. Полиморфизм. Относится к практике использования одного интерфейса для представления нескольких типов объектов.
   Полиморфизм позволяет нам писать более общий код, который может работать с широким спектром объектов, без
   необходимости знать конкретные детали каждого объекта.

В Python мы можем использовать принципы ООП для создания классов и объектов, которые инкапсулируют данные и
функциональность. Мы можем определить классы, используя ключевое слово “class”, а затем создать экземпляры этих классов,
используя имя класса, за которым следуют круглые скобки. Например:

1. **<code><em>class Person:</em></code></strong>
2. <code><em>   <strong>def</strong> __init__(self, name, age):</em></code>
3. <code><em>       self.name = name</em></code>
4. <code><em>       self.age = age</em></code>
5. <code><em> </em></code>
6. <code><em>   <strong>def</strong> say_hello(self):</em></code>
7. <code><em>       <strong>print</strong>(f'Hello, my name is {self.name} and I am {self.age} years old.')</em></code>
8. <code><em> </em></code>
9. <code><em> </em></code>
10. <code><em>person1 = Person('John', 30)</em></code>
11. <code><em>person2 = Person('Jane', 25)</em></code>
12. <code><em> </em></code>
13. <code><em>person1.say_hello()  # prints "Hello, my name is John and I am 30 years old."</em></code>
14. <code><em>person2.say_hello()  # prints "Hello, my name is Jane and I am 25 years old."</em></code>
15. <code><em> </em></code>

В этом примере мы определяем класс “Person”, который имеет два атрибута (“name” и “age”) и один метод (“say_hello()”).
Затем мы создаем два экземпляра класса “Person” (“person1” и “person2”) и вызываем метод “say_hello()” для каждого
экземпляра.

В целом, принципы ООП являются важным инструментом для создания более модульного, повторно используемого и
поддерживаемого кода в Python. Освоив использование ООП, вы сможете поднять свои навыки программирования на новый
уровень и создавать более мощные, гибкие и эффективные программы. К тому же, ООП повсеместно используется в
автоматизации тестирования и наибольшее распространение получила Page Model Object, о которой мы поговорим позже.

<h2>Глава 5. Знакомство с Selenium</h2>

<h3>5.1 Что такое Selenium?</h3>

Selenium — это среда тестирования программного обеспечения с открытым исходным кодом, которая используется для
автоматизации веб-приложений. Она предоставляет набор инструментов и API, которые позволяют QA-инженерам
автоматизировать тестирование и решать задачи, такие как взаимодействие с пользователем, ввод данных и проверка вывода.
Selenium поддерживает различные языки программирования, такие как Java, Python, C#, Ruby, JavaScript и другие.

Selenium работает, имитируя действия пользователя в веб-браузере. Он использует компонент драйвера, который
взаимодействует с веб-браузером и позволяет тестам автоматизации взаимодействовать с веб-страницей. Драйвер Selenium
WebDriver является наиболее часто используемым драйвером и поддерживает популярные браузеры, такие как Chrome, Firefox,

Safari и Edge.

Вот несколько способов использования Selenium для автоматизированного тестирования.

Функциональное тестирование: Selenium можно использовать для автоматизации функциональных тестов, чтобы убедиться, что
веб-приложения работают должным образом. Это включает в себя проверку того, что элементы пользовательского интерфейса
отображаются правильно, что ссылки и кнопки работают должным образом, а поля формы принимают допустимый ввод.

Регрессионное тестирование: Selenium можно использовать для автоматизации регрессионных тестов, чтобы гарантировать, что
изменения, внесённые в веб-приложение, не привели к появлению новых ошибок или проблем. Регрессионные тесты можно
запускать несколько раз, чтобы убедиться, что приложение продолжает функционировать должным образом после каждого
внесения изменений. Тут стоит отметить тот факт, что именно регрессионное тестирование является первым кандидатом на
автоматизацию.

Интеграционное тестирование: Selenium можно использовать для автоматизации интеграционных тестов, чтобы убедиться, что
различные части веб-приложения работают вместе правильно. Это включает в себя тестирование взаимодействия между
интерфейсными и внутренними компонентами веб-приложения. Стоит упомянуть, что большинство авторов относят автоматизацию
тестирования UI к End-to-end тестам, так как они проходят через всё приложение начиная от ввода в пользовательский
интерфейс и заканчивая выводом конечных данных в нём же.

Кросс-браузерное тестирование: Selenium можно использовать для автоматизации кросс-браузерного тестирования, чтобы
убедиться, что веб-приложения работают согласованно в разных браузерах и версиях. Это помогает выявлять и устранять
проблемы, связанные с браузерами.

В целом, Selenium — это мощный инструмент для автоматизации тестирования веб-приложений, который может помочь
QA-инженерам сэкономить время и силы за счёт автоматизации повторяющихся и трудоёмких задач тестирования.

<h3>5.2 Настройка первого запуска браузера с помощью Selenium Webdriver</h3>

На этом этапе я рекомендую создать свой учебный репозиторий в GitHub и повторять и анализировать действия в среде
разработке PyCharm[^11]. Создайте свой проект, настройте виртуальное окружение и не забудьте про README.md файл.
Рекомендую добавить README.md и .gitignore для Python сразу при создании репозитория в GitHub.

Мы будем с вами изучать автоматизацию на языке Python, поэтому первое, что вы должны сделать - это скачать версию
3.11.2[^12] (на момент написания - это последняя версия языка Python).

В виртуальном окружении устанавливаем библиотеку Selenium: “pip install selenium==4.*”.

В этом дипломном проекте мы будем работать с драйвером для Chrome, так как на данный момент это самый популярный браузер
согласно ресурсу statcounter[^13], и в первую очередь следует убедиться, что веб-приложение работает для большинства
пользователей.



<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image7.png "image_tooltip")

Рисунок 7. Статистика использования браузеров.

Драйвер для Chrome разрабатывается командой браузера и носит название ChromeDriver. Скачать нужную версию можно с
официального сайта.[^14]

Подробности установки драйвера хорошо описаны на сайте selenium-python.com[^15].

Далее мы создадим скрипт, который открывает веб-страницу и заполняет форму. Я буду использовать сайты demoqa.com[^16] и
testpages.herokuapp.com[^17] для демонстрации возможностей Selenium.

Рекомендую попробовать запускать команды по отдельности или пользоваться отладчиком среды разработки, чтобы получить
более глубокое понимание работы программы.

1. **<code>import time</code></strong>
2. <code> </code>
3. <code><em># webdriver - это набор команд для управления браузером.</em></code>
4. <strong><code>from selenium import webdriver</code></strong>
5. <code> </code>
6. <code><em># By - класс, который позволяет выбрать способ поиска элемента.</em></code>
7. <strong><code>from selenium.webdriver.common.by import By</code></strong>
8. <code> </code>
9. <code><em># Инициализация браузера Chrome.</em></code>
10. <code>driver = webdriver.Chrome()</code>
11. <code> </code>
12. <code><em># Задержка в 5 секунд, чтобы вы увидили, что происходит в браузере.</em></code>
13. <code><em># Попробуйте её закомментировать и посмотреть, что из этого выйдет.</em></code>
14. <code>time.sleep(5)</code>
15. <code> </code>
16. <code><em># Метод get открывает страницу в браузере.</em></code>
17. <code>driver.get('https://testpages.herokuapp.com/styled/basic-html-form-test.html')</code>
18. <code>time.sleep(5)</code>
19. <code> </code>
20. <code><em># Метод find_element() позволяет найти нужный элемент на сайте по указанному локатору (
    селектору).</em></code>
21. <code><em># Метод принимает в качестве аргументов способ поиска элемента и значение, по которому будет
    осуществляться поиск.</em></code>
22. <code><em># Ищем поле ввода.</em></code>
23. <code>username_field = driver.find_element(By.CSS_SELECTOR, '[name="username"]')</code>
24. <code> </code>
25. <code><em># Вводим текст в поле, используя метод send_keys().</em></code>
26. <code>username_field.send_keys('Alexander')</code>
27. <code>time.sleep(5)</code>
28. <code> </code>
29. <code><em># Найдем кнопку, которая отправляет введённый текст.</em></code>
30. <code>submit_button = driver.find_element(By.CSS_SELECTOR, '[value="submit"]')</code>
31. <code> </code>
32. <code><em># Скажем драйверу, что нужно кликнуть по кнопке.</em></code>
33. <code><em># После этой команды мы должны увидеть ввёденные значения в форму.</em></code>
34. <code>submit_button.click()</code>
35. <code>time.sleep(5)</code>
36. <code> </code>
37. <code><em># Мы должны не забыть закрыть окно браузера, но если этого не сделать, то за нас это сделает сборщик
    мусора Python.</em></code>
38. <code>driver.quit()</code>
39. <code> </code>

Пронаблюдайте за работой скрипта, а затем еще раз пробегитесь по коду глазами. Одна из особенностей языка Python в том,
что он пишется почти как предложения на английском языке. Такая высокая читаемость кода позволяет гораздо легче изучать
язык.

Следует обязательно добавить к проекту файл “requirements.txt”. В этот файл следует занести все зависимости, которые
используются для работы вашей программы, чтобы любой мог склонировать себе ваш репозиторий и запустить его на своей
локальной машине.

Записать такой файл можно вручную или воспользоваться командой: “pip freeze > requirements.txt”.

<h3>5.3 Поиск элементов</h3>

Тема поиска элементов критично важна для автоматизации тестирования UI и мы остановимся на ней подробнее.

<h4>5.3.1 Поиск элементов с помощью CSS-селекторов</h4>

Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

* id;
* значение атрибута;
* name;
* class;
* tag.

Использование тега для поиска элемента используется в сочетание с другими частями элемент, потому что важно выбрать
единственный объект для взаимодействия кроме некоторый исключений из этого правила. И, как правило, на странице
присутствует несколько элементов с одинаковым тегом, а когда таких элементов нет все равно не рекомендуется использовать
исключительно тег элемента, так как страница может измениться: могут быть добавлены новые элементы, изменено наполнение
страницы.

Давайте откроем страницу Basic Web Page Title[^18] и попробуем найти элемент первого параграфа.

Чтобы это сделать вам потребуется использовать DevTools вашего браузера.

Инструменты разработчика (от англ. "development tools" или сокращённо "DevTools") - это программы, которые позволяют
создавать, тестировать и отлаживать (debug) программное обеспечение.[^19]

Я рекомендую вам использовать Google Chrome.

Для включения DevTools можно нажать F12 на клавиатуре.

Ниже приведён кусок html-кода страницы:

1. <code><<strong>div</strong> class="centered"></code>
2. <code>   <<strong>p</strong> id="para1" class="main">A paragraph of text</<strong>p</strong>></code>
3. <code>   <<strong>p</strong> id="para2" class="sub">Another paragraph of text</<strong>p</strong>></code>
4. <code></<strong>div</strong>></code>

<h5>5.3.1.1 Поиск по id</h5>

У элемента с первым параграфом есть атрибут id=”para1”, а значит, мы однозначно можем найти его с помощью селектора
“#para1” (символ “#” означает, что мы ищем по “id” со значением “para1”).

Нужно всегда проверять правильность подобранного локатора в консоли разработчика. Откройте консоль разработчика и
перейдите в ней в таб “Elements”. Затем нажмите “ctrl+F” и в открывшейся внизу поисковой строке введите “#para1”. Если
селектор написан правильно,

то вы увидите подсвеченный элемент на веб-странице, а также элемент будет подсвечен жёлтым цветом в html-коде. Еще в
поисковой строке вы увидите количество найденных элементов.



<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image8.png "image_tooltip")

Рисунок 8. Поиск по id.

<h5>5.3.1.2 Поиск по class</h5>

Рассмотрим поиск второго параграфа по классу. Поскольку классы используются повсеместно для задания стилей элементов, то
у них есть краткая форма поиска: “.sub”. Необходимо указать на использование класса для поиска использовав точку, а
затем ввести значение класса.



<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image9.png "image_tooltip")

Рисунок 9. Поиск по class.

Важно отметить, что поиск по классу чувствителен к регистру и поиск “.Sub” уже не найдёт нужный элемент.

<h5>5.3.1.3 Поиск по tag</h5>

Чтобы найти элемент по тегу, просто напишите название тега в поисковой строке. Поиск по тегам не очень удобен, т.к.
разработчики используют небольшое количество тегов для разметки страниц, и скорее всего, одному тегу будет
соответствовать несколько элементов. Но есть некоторые теги, которые почти наверняка будут присутствовать в единичном
экземпляре: html, title, h1.

Давайте попробуем найти заголовок нашей страницы Basic Web Page Title[^20].



<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image10.png "image_tooltip")

Рисунок 10. Поиск по tag.

<h5>5.3.1.4 Поиск по значению атрибута</h5>

Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по “id” в следующем
виде “[id="para1"]” вместо “#para1” и поиск по “class” в следующем виде “[class="sub"]” вместо “.sub”.

Вариант с квадратными скобками принято использовать для тех видов поиска, у которых отсутствует короткая поисковая
команда.

Рассмотрим пример параграфа с атрибутами (This paragraph has attributes) и попробуем найти содержащий его элемент на
странице Test Page For Element Attributes[^21].



<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image11.png "image_tooltip")

Рисунок 11. Поиск по значению атрибута.

Поиск по “name” является разновидностью поиска по значению атрибута и выделяется отдельно в Selenium WebDriver.

<h5>5.3.1.5 Поиск элементов с помощью составных CSS-селекторов</h5>

Допустим мы не можем найти необходимый нам элемент на странице используя простой селектор, так как он находит сразу
несколько элементов сразу. Что делать в такой ситуации?

Вот тут нам и понадобится умение комбинировать селекторы и иерархическая структура страницы.

<h6>5.3.1.5.1 Использование порядкового номера дочернего элемента</h6>

Например, нам необходимо получить только текст пункта “The Attributes window, has no name.” на странице Windows Example
Test[^22].



<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image12.png "image_tooltip")

Рисунок 12. Поиск с использованием порядкового номера дочернего элемента.

Псевдокласс “:nth-child(3)” позволяет выбрать третий дочерний элемент тега “ul” с тегом “li”.

<h6>5.3.1.5.2 Использование дочерних элементов</h6>

Допустим нам нужно содержимое параграфа “This is a paragraph text” на странице Welcome to the Find By Playground[^23],
заключённое в тег “a”. Для этого можно использовать следующую команду для поиска элемента: “.specialDiv > p.normal #a1”.

Символ “>” означает, что нужно взять элемент строго на один уровень вложенности ниже элемента с классом specialDiv. Этот
элемент должен иметь тег “p” и класс “normal”, а уже далее от этого элемента производится поиск по “id”.



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image13.png "image_tooltip")

Рисунок 13. Поиск с использованием дочернего элемента.

<h6>5.3.1.5.3 Использование потомков</h6>

Попробуем найти ввод цвета (Colour) на странице HTML5 Form Elements Test Page[^24].

Можно написать следующий локатор элемента: “.page-body .centered .form-label [name="colour"]”.



<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image14.png "image_tooltip")

Рисунок 14. Поиск с использованием потомков.

Пробел является значащим в CSS-селекторах, это разделитель предка и потомка. Потомок может находиться на любом уровне
вложенности, так например все элементы с классом “centered” являются потомками класса “page-body”.

<h4>5.3.2 Поиск элементов с помощью XPath</h4>

XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа.[^25] Это мощный и
гибкий инструмент, который позволяет использовать сложные поисковые запросы для нахождения нужного элемента.

Разберём кратко особенности синтаксиса XPath.

1. XPath запрос всегда начинается с символа “/” или “//”.

Символ “/” аналогичен символу “>” в CSS-селекторе, а символ “//” - пробелу.

Разница в том, что когда мы используем символ “/” в XPath локаторе, то мы всегда обязаны указывать корень документа. У
html страницы корнем всегда будет элемент с тегом “<html>”.

Мы можем начать XPath запрос с символа “//” - это будет означать, что мы хотим найти всех потомков корневого элемента
без его указания.

2. Квадратные скобки “[ ]” - это команда фильтрации в XPath.

Некоторые правила фильтрации, которые могут вам пригодится в составлении XPath-селекторов рассмотрим на примере страницы
DEMOQA Practice Form[^26].

* По любому атрибуту будь то class, name, type или любой другой. Например, нам нужна кнопка “Submit”:
  “//button[@type="submit"]”.
* По порядковому номеру. Допустим нам необходимо найти радиобаттон женского пола в форме для активации. Для этого
  подойдет следующий локатор: “//div[@id="genterWrapper"]/div/div[2]/input”, где “[2]” будет означать, что из списка
  элементов, которые подходят под данный локатор необходимо выбрать второй по счёту.
* По частичному совпадению. Мы можем найти элемент по внутреннему тексту, который расположен внутри него используя
  функцию “text()”. Давайте найдём таким методом кнопку “Submit”: “//button[contains(text(), "Submit")]”. Также этот
  метод подойдет для поиска частичного совпадения атрибутов, например, для поиска поля ввода текущего адреса:
  “//textarea[contains(@class, "form")]”. Обратите внимание, что класса “form” нет у поля ввода адреса, но есть класс
  “form-control”, который и нашёл наш селектор.

3. Символ “*” - команда выбора всех элементов.

Может быть удобна для выбора всех интересующих нас элементов или когда точно неизвестен тег элемента для поиска:
“//div/*[@class="form-control"]”

4. Поиск по классам с помощью XPath регистрозависим также как и в CSS-селекторах.

Поиск по локатору “//div/*[@class="Form-control"]” не даст результатов.

Мы рассмотрели базовые селекторы, которых будет достаточно для написания простых UI-тестов.

<h3>5.4 Поиск элементов с помощью Selenium WebDriver</h3>

<h4>5.4.1 Поиск элементов с помощью Selenium</h4>

Для поиска элементов на странице в Selenium WebDriver используются несколько методов, позволяющих искать по
CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод “find_element”, который принимает два
аргумента - тип локатора и значение локатора.

Существуют следующие методы поиска элементов:

* “find_element(By.ID, value)” - поиск по уникальному атрибуту “id” элемента;
* “find_element(By.CSS_SELECTOR, value)” - поиск элемента с помощью правил на основе CSS;
* “find_element(By.XPATH, value)” - поиск с помощью языка запросов XPath;
* “find_element(By.NAME, value)” - поиск по атрибуту name элемента;
* “find_element(By.TAG_NAME, value)” - поиск элемента по названию тега элемента;
* “find_element(By.CLASS_NAME, value)” - поиск по значению атрибута class;
* “find_element(By.LINK_TEXT, value)” - поиск ссылки на странице по полному совпадению;
* “find_element(By.PARTIAL_LINK_TEXT, value)” - поиск ссылки на странице, если текст селектора совпадает с любой частью
  текста ссылки.

На практике используются “find_element(By.CSS_SELECTOR, value)” и “find_element(By.XPATH, value)” чаще всего, изменяя
только значение.

Давайте найдем кнопку “Submit” на странице DEMOQA Text Box[^27].

Сперва заходим на сайт и находим уникальный селектор для кнопки. Нам повезло и у кнопки есть атрибут “id”: “id="
submit"”.

Посмотрим на код:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>browser.get('https://demoqa.com/text-box')</code>
6. <code>button = browser.find_element(By.CSS_SELECTOR, '#submit')</code>
7. <code> </code>

Класс By содержит все возможные локаторы. Вы можете использовать какой-нибудь другой.

Поиск нескольких элементов.

Вы можете столкнуться с ситуацией, когда вам нужно получить сразу несколько элементов или собрать коллекцию похожих
элементов для выполнения с ними каких-либо операций. Для этих целей есть метод “find_elements()”, который мы рассмотрим
чуть позже.

<h4>5.4.2 Работа с браузером в Selenium</h4>

Если вы запускаете примеры кода в своей среде разработке, то скорее всего вы задались вопросом о причине закрытия
браузера, хотя явного закрытия браузера в коде нет. Дело в работе сборщика мусора Python, который делает это за нас. Но
все же правильным будет указывать явно закрытие браузера.

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>link = 'https://demoqa.com/buttons'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(link)</code>
7. <code>click_me_button = browser.find_element(By.CSS_SELECTOR, '.col-md-6 div:nth-child(3) button')</code>
8. <code>click_me_button.click()</code>
9. <code> </code>
10. <code><em># закрываем браузер после всех манипуляций</em></code>
11. <code>browser.quit()</code>
12. <code> </code>

Но что произойдёт, если до момента закрытия браузера возникнет ошибка?

Один из подходов к решению этой проблемы - это использование конструкции “try/finally”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>link = 'https://demoqa.com/buttons'</code>
5. <strong><code>try:</code></strong>
6. <code>   browser = webdriver.Chrome()</code>
7. <code>   browser.get(link)</code>
8. <code>   click_me_button = browser.find_element(By.CSS_SELECTOR, '.col-md-6 div:nth-child(3) button')</code>
9. <code>   click_me_button.click()</code>
10. <strong><code>finally:</code></strong>
11. <code>   <em># закрываем браузер после всех манипуляций</em></code>
12. <code>   browser.quit()</code>
13. <code> </code>

<h5>5.4.2.1 Поиск всех необходимых элементов.</h5>

Допустим вам необходимо убедиться, что присутствуют все девять элементов содержащие гиперссылки на странице DEMOQA
Links[^28]. Для этого вы можете использовать метод “find_elements()” и написать следующий код:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>page = 'https://demoqa.com/links'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(page)</code>
7. <code> </code>
8. <code>link_locator = (By.CSS_SELECTOR, '#linkWrapper p a')</code>
9. <code> </code>
10. <code>links = browser.find_elements(*link_locator)</code>
11. <code>number_of_links = len(links)</code>
12. <code> </code>
13. <code>browser.quit()</code>
14. <code> </code>
15. <code><em># Проверяем, что количество ссылок на странице равно 9.</em></code>
16. <strong><code>assert number_of_links == 9</code></strong>
17. <code> </code>

Отметим несколько важных моментов касательно поиска элементов.

* Идеальный селекто - это уникальный селектор, который идентифицирует один конкретный элемент на странице.
* Эффективные автотесты - тесты, сосредоточенные на проверки отдельных функциональных единиц. Не стоит писать большие
  тестовые сценарии, так как простые тесты легче читаются вашими коллегами и позволяют быстро найти проблему, если один
  из тестов упадёт.
* Использование метода “sleep()” из библиотеки “time” для ожидания загрузки или изменения свойств элементов считается
  плохой практикой, так как заранее сложно спрогнозировать время ожидания, которое зависит от большого числа внешних
  факторов. Мы ещё вернёмся к решению этого вопроса более красивыми методами, а пока вы можете использовать
  “time.sleep()” для наглядности.

<h2>Глава 6. Полезные методы Selenium</h2>

<h3>6.1 Как работать с элементами типа checkbox и radiobutton?</h3>

Checkbox (чекбокс) и radiobutton (радиобаттон или переключатель) — часто используемые в формах элементы. Основная
разница между ними состоит в том, что чекбоксы позволяют выбирать/отключать любой из представленных вариантов, а
переключатели позволяют выбрать только один из вариантов. Далее мы будем называть эти элементы на англоязычный манер:
checkbox и radiobutton.

Оба этих элемента создаются при помощи тега `input` со значением атрибута `type` равным “checkbox” или “radio”
соответственно. В html-коде DEMOQA Practice Form[^29] страницы вы увидите:

<**input** name="gender" required="" type="radio" id="gender-radio-1" class="custom-control-input" value="Male">

<**input** type="checkbox" id="hobbies-checkbox-1" class="custom-control-input" value="1">

Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута “name”, но разные значения
атрибута “value”:

<**input** name="gender" required="" type="radio" id="gender-radio-1" class="custom-control-input" value="Male">

<**input** name="gender" required="" type="radio" id="gender-radio-2" class="custom-control-input" value="Female">

<**input** name="gender" required="" type="radio" id="gender-radio-3" class="custom-control-input" value="Other">

Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с
помощью значения “id” или значения атрибута “value”.

Чтобы выбрать элемент, необходимо кликнуть по нему, для этого необходимо использовать метод “click()” для найденного
элемента.

Пример выбора radiobutton пола Other в форме:

1. `gender_other_radio = browser.find_element(By.CSS_SELECTOR, "[value='Other']")`
2. `gender_other_radio.click()`

Рядом с радиобаттоном вы увидите тег “label”, который позволяет кликать по тексту. Текст заключен в тег “label”. Элемент
“label” связан с элементом ввода с помощью атрибута “for”, который соответствует значению атрибута “id” элемента ввода:

1. <code><<strong>div</strong> class="custom-control custom-radio custom-control-inline"></code>
2. <code>   <<strong>input</strong> name="gender" required="" type="radio" id="gender-radio-2" class="custom-control-input"</code>
3. <code>   value="Female"></code>
4. <code>   <<strong>label</strong> title="" for="gender-radio-2" class="custom-control-label">Female</<strong>label</strong>></code>
5. <code></<strong>div</strong>></code>

Раз текст радиобаттона кликабельный, то можно использовать метод “click()” на нём.

<h3>6.2 Метод get_attribute()</h3>

Для более детальный проверок в тестах нам может потребоваться получать значение атрибутов HTML. Атрибуты могут быть как
стандартными, например: alt, color, placeholder и другими, так и созданными разработчиками для задания собственных
стилей или правил. Подробнее ознакомиться со стандартным списком HTML атрибутов вы сможете в статье HTML Attribute
Reference[^30].

Давайте посмотрим на страницу DEMOQA Links[^31] ещё раз. На этой странице есть ссылки, которые ведут на другие страницы
и ссылки, которые отправляют запросы к API. Допустим, что нам необходимо проверить, что ссылка “Home” действительно
содержит ссылку на домашнюю страницу сайта. Для этого посмотрим на оформление HTML-кода элемента:

<**a** id="simpleLink" href="https://demoqa.com" target="_blank">Home</**a**>

Атрибут “href” определяет URL страницы, на которую ведёт ссылка. Чтобы получить этот или любой другой атрибут нам
необходимо воспользоваться методом get_attribute() для найденного элемента.

Давайте попробуем написать тест, который будет проверять корректность указанного URL у ссылки “Home”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>page = 'https://demoqa.com/links'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(page)</code>
7. <code> </code>
8. <code>home_link_locator = (By.CSS_SELECTOR, '#simpleLink')</code>
9. <code> </code>
10. <code>home_link = browser.find_element(*home_link_locator)</code>
11. <code>home_link_href = home_link.get_attribute('href')</code>
12. <code> </code>
13. <code>browser.quit()</code>
14. <code> </code>
15. <code><em># Проверяем, что ссылка у ссылки именно та, что должна быть.</em></code>
16. <strong><code>assert home_link_href == 'https://demoqa.com/'</code></strong>
17. <code> </code>

Хорошей практикой является написание подробного сообщения об ошибке при проверке, чтобы сразу стало понятно, что пошло
не так. Давайте напишем заведомо провальный тест с подробным описанием для проверки плейсхолдера в поле ввода “Full
Name” на странице DEMOQA Text Box[^32].

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>page = 'https://demoqa.com/text-box'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(page)</code>
7. <code> </code>
8. <code>full_name_field_locator = (By.CSS_SELECTOR, '#userName')</code>
9. <code> </code>
10. <code>full_name_field = browser.find_element(*full_name_field_locator)</code>
11. <code>full_name_field_placeholder = full_name_field.get_attribute('placeholder')</code>
12. <code>expected_full_name_field_placeholder = 'Current Address'</code>
13. <code> </code>
14. <code>browser.quit()</code>
15. <code> </code>
16. <strong><code>assert full_name_field_placeholder == expected_full_name_field_placeholder, \</code></strong>
17. <code>   f'Expected {expected_full_name_field_placeholder=}.' \</code>
18. <code>   f'<strong>\n</strong>Got: {full_name_field_placeholder=}'</code>
19. <code> </code>

При запуске такого теста вы получите “AssertionError”, так как плейсхолдер будет получен не тот, что вы написали в
ожидаемом результате:

1. <code>test_full_name_placeholder.py:None <strong>(</strong>test_full_name_placeholder.py<strong>)</strong></code>
2. <code>test_full_name_placeholder.py:16: <strong>in</strong> <strong><</strong>module<strong>></strong></code>
3. <code>   assert full_name_field_placeholder == expected_full_name_field_placeholder, \</code>
4. <code>E AssertionError: Expected expected_full_name_field_placeholder='Current Address'.</code>
5. <code>E Got: full_name_field_placeholder='Full Name'</code>
6. <code>E assert 'Full Name' == 'Current Address'</code>

Мы использовали форматирование строк и подробное описание ожидаемого и фактического результата в нашем тесте. Теперь,
будет легко понять, что за ошибка произошла при выполнении тестового скрипта. Следует отметить, что нарочитое
проваливание написанных тестов - это одна из хороших практик при написании тестовых сценариев, которой вы должны всегда
придерживаться. Следует обращать внимание на то, что тест действительно проваливается при неверных входных данных и
понятность сообщения об ошибке.

<h3>6.3 Работа с файлами, списками и js-скриптами</h3>

<h4>6.3.1 Работа со списками</h4>

На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных
особенностей:

* у каждого элемента списка обычно есть уникальное значение атрибута “value”;
* в списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка.

Давайте посмотрим как выглядит выпадающий список “Old Style Select Menu” в HTML-коде на странице DEMOQA Select
Menu[^33]:

<**select** id="oldSelectMenu">

    <**option** value="red">Red</**option**>

    <**option** value="1">Blue</**option**>

    <**option** value="2">Green</**option**>

    <**option** value="3">Yellow</**option**>

    <**option** value="4">Purple</**option**>

    <**option** value="5">Black</**option**>

    <**option** value="6">White</**option**>

    <**option** value="7">Voilet</**option**>

    <**option** value="8">Indigo</**option**>

    <**option** value="9">Magenta</**option**>

    <**option** value="10">Aqua</**option**>

</**select**>

Варианты ответа задаются тегом “option”, значение “value” может отсутствовать.

Давайте воспользуемся привычным уже нам методом “click()” для выбора ответа. Для этого сперва нам нужно раскрыть
выпадающий список кликнув на “select” и затем уже кликнуть на один из вариантов.

Код может быть следующим:

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>page_link = 'https://demoqa.com/select-menu'</code>
6. <code>browser = webdriver.Chrome()</code>
7. <code>browser.get(page_link)</code>
8. <code> </code>
9. <code>old_style_select_menu_locator = (By.CSS_SELECTOR, '#oldSelectMenu')</code>
10. <code>purple_color_locator = (By.CSS_SELECTOR, 'option:nth-child(5)')</code>
11. <code> </code>
12. <code>browser.find_element(*old_style_select_menu_locator).click()</code>
13. <code>sleep(1)</code>
14. <code>browser.find_element(*purple_color_locator).click()</code>
15. <code>sleep(1)</code>
16. <code> </code>

Есть более удобный способ, для которого используется специальный класс “Select” из библиотеки “WebDriver”. Вначале мы
должны инициализировать новый объект. Далее можно найти любой вариант из списка с помощью метода “select_by_value()”:

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <strong><code>from selenium.webdriver.support.ui import Select</code></strong>
5. <code> </code>
6. <code>page_link = 'https://demoqa.com/select-menu'</code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>browser.get(page_link)</code>
9. <code> </code>
10. <code>old_style_select_menu_locator = (By.CSS_SELECTOR, '#oldSelectMenu')</code>
11. <code>select = Select(browser.find_element(*old_style_select_menu_locator))</code>
12. <code>select.select_by_value('4')</code>
13. <code>sleep(1)</code>
14. <code> </code>

Есть ещё два метода “select_by_index()” и “select_by_visible_text()”. Первый ищет по индексу элемента и индексация
начинается с нуля, а второй по видимому тексту.

<h4>6.3.2 Метод execute_script()</h4>

Вот еще один метод, одновременно мощный и очень полезный, хотя и требующий некоторых базовых знаний JavaScript. Метод
“execute_script()” позволяет запускать код JavaScript в браузере при выполнении скрипта автоматизированного
тестирования. Хотя сначала это может показаться ненужным, поскольку автоматические тесты обычно взаимодействуют с
интерфейсом веб-сайта так же, как обычный пользователь, нажимая кнопки, выбирая пункты меню и вводя текст в поля, бывают
ситуации, когда выполнение JavaScript может быть невероятно полезным.

Стандартные методы Selenium могут оказаться недостаточными для всех сценариев веб-приложений. Веб-сайты сильно
различаются по назначению: от простых блогов до сложных финансовых или графических приложений. Разработчики имеют доступ
к огромному количеству библиотек для решения бизнес-сценариев, включая нестандартные текстовые редакторы, уникальные
меню и оригинальные видеоплееры на веб-страницах. В некоторых случаях тестировщикам может потребоваться написать скрипт
JavaScript для взаимодействия с, казалось бы, обычными кнопками. Когда это происходит, важно обратиться за помощью к
фронтэнд-разработчикам и попросить пример желаемого сценария. Тестировщики могут протестировать скрипт, выполнив его в
консоли браузера перед добавлением в автотест с помощью метода “execute_script(javascript_code)”.

Давайте попробуем вызвать “alert” в браузере с помощью WebDriver. Пример сценария:

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>browser.execute_script("alert('Hello world!');")</code>
6. <code>sleep(2)</code>
7. <code> </code>

Очень часто вы будете сталкиваться с ситуацией, когда вам нужно кликнуть на элемент, который есть на странице, но
необходимо проскроллить страницу, чтобы элемент стал видимым и скрипт сработал. Для этого вам потребуется использовать
код JavaScript: “return arguments[0].scrollIntoView(true);”.

Но давайте рассмотрим пример поинтереснее. Возьмём страницу DEMOQA Practice Form[^34] и попробуем нажать на кнопку
“Submit”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>practice_form_page_link = "https://demoqa.com/automation-practice-form"</code>
6. <code>browser.get(practice_form_page_link)</code>
7. <code> </code>
8. <code><em># browser.execute_script('document.getElementsByTagName(\'footer\')[0].remove();',
   practice_form_page_link)</em></code>
9. <code><em># browser.execute_script('document.getElementById(\'close-fixedban\').remove();')</em></code>
10. <code>submit_button = browser.find_element(By.CSS_SELECTOR, "#submit")</code>
11. <code>submit_button.click()</code>
12. <code> </code>

Получим исключение “ElementClickInterceptedException”, потому что у нас на странице дефект и футер перекрывает кнопку
“Submit”. Для того чтобы проверить работу формы и обойти этот дефект мы можем удалить элемент с помощью JavaScript
скрипта. Раскомментируйте восьмую и девятую строчки кода и перезапустите тест.

<h4>6.3.3 Загрузка файлов</h4>

Если нам понадобится загрузить файл на веб-странице, мы можем использовать уже знакомый нам метод “send_keys”. Только
теперь нам нужно в качестве аргумента передать путь к нужному файлу на диске вместо простого текста.

Чтобы указать путь к файлу, можно использовать стандартный модуль Python для работы с операционной системой — os. В этом
случае ваш код не будет зависеть от операционной системы, которую вы используете. Добавление файла будет работать и на
Windows, и на Linux, и даже на MaсOS.

Пример кода для загрузки файла на сайт:

1. **<code>from os import path, remove</code></strong>
2. <strong><code>from time import sleep</code></strong>
3. <strong><code>from random import randint</code></strong>
4. <strong><code>from selenium import webdriver</code></strong>
5. <strong><code>from selenium.webdriver.common.by import By</code></strong>
6. <code> </code>
7. <code> </code>
8. <strong><code>def generated_file() -> tuple[str, str]:</code></strong>
9. <code>   """</code>
10. <code>   File generation.</code>
11. <code>   :returns: file name and absolute path.</code>
12. <code>   """</code>
13. <code>   file_path = f'filetest{randint(0, 999)}.txt'</code>
14. <code>   <strong>with</strong> open(file_path, 'w+', encoding='UTF-8') <strong>as</strong> file:</code>
15. <code>       file.write(f'Hello, world!{randint(0, 999)}')</code>
16. <code>   <strong>return</strong> file.name, path.abspath(file_path)</code>
17. <code> </code>
18. <code> </code>
19. <code>browser = webdriver.Chrome()</code>
20. <code>upload_and_download_page_link = 'https://demoqa.com/upload-download'</code>
21. <code>browser.get(upload_and_download_page_link)</code>
22. <code> </code>
23. <code>file_name, file_path = generated_file()</code>
24. <code> </code>
25. <code>upload_button_locator = (By.CSS_SELECTOR, '#uploadFile')</code>
26. <code>upload_button = browser.find_element(*upload_button_locator)</code>
27. <code>upload_button.send_keys(file_path)</code>
28. <code>remove(file_path)</code>
29. <code>sleep(3)</code>
30. <code> </code>

<h4>6.3.4 Работа с окнами</h4>

<h5>6.3.4.1 Alerts</h5>

Мы уже сталкивались с разными видами уведомлений, но не писали тестовые сценарии для их проверки. Предположим нам надо
проверить содержание alert-а и нажать на кнопку “ОК”, чтобы его закрыть. Для того, чтобы закрыть предупреждение, скрипт
должен сначала переключиться в окно alert-а, а затем использовать команду “accept()”.

Давайте напишем небольшой тестовый сценарий для страницы DEMOQA Alerts[^35]:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>alerts_page_link = 'https://demoqa.com/alerts'</code>
6. <code>browser.get(alerts_page_link)</code>
7. <code> </code>
8. <code>alert_button_locator = (By.CSS_SELECTOR, '#alertButton')</code>
9. <code>alert_button = browser.find_element(*alert_button_locator)</code>
10. <code>alert_button.click()</code>
11. <code>alert = browser.switch_to.alert</code>
12. <code> </code>
13. <code>alert_text = alert.text</code>
14. <code>expected_alert_text = 'You clicked a button'</code>
15. <code>alert.accept()</code>
16. <code> </code>
17. <strong><code>assert alert_text == expected_alert_text, \</code></strong>
18. <code>   f'Expected alert text to be {expected_alert_text}.' \</code>
19. <code>   f'<strong>\n</strong> Got {alert_text} instead.'</code>
20. <code> </code>

Следующий тип модального окна - confirm отличается от alert тем, что его можно либо принять, либо отменить. Чтобы
принять нужно использовать метод “accept()”, чтобы отменить - метод “dismiss()”.

Третий тип модального окна - “prompt” - имеет дополнительное поле для ввода текста. Чтобы ввести текст, нужно
использовать уже знакомый нам метод “send_keys()”.

Давайте напишем тестовый сценарий для проверки текста, который мы введём в модальном окне prompt. Сначала проделайте
такой тест вручную: вызовите prompt, введите текст, нажмите кнопку “ОК”, проверьте текст расположенный слева от
prompt-а, там будет введённый текст сообщения. Теперь попробуем автоматизировать этот тестовый сценарий:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>prompt_button_locator = (By.XPATH, '//button[@id="promtButton"]')</code>
5. <code>prompt_result_locator = (By.XPATH, '//span[@id="promptResult"]')</code>
6. <code> </code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>alerts_page_link = 'https://demoqa.com/alerts'</code>
9. <code>browser.get(alerts_page_link)</code>
10. <code> </code>
11. <code>prompt_button = browser.find_element(*prompt_button_locator)</code>
12. <code>prompt_button.click()</code>
13. <code> </code>
14. <code>prompt = browser.switch_to.alert</code>
15. <code>input_text_to_prompt = 'Hello_world!'</code>
16. <code>prompt.send_keys(input_text_to_prompt)</code>
17. <code>prompt.accept()</code>
18. <code> </code>
19. <code>prompt_result = browser.find_element(*prompt_result_locator)</code>
20. <code>prompt_result_text = prompt_result.text.split()[-1]</code>
21. <code> </code>
22. <strong><code>assert prompt_result_text == input_text_to_prompt, \</code></strong>
23. <code>   f'Entered text to prompt was {input_text_to_prompt}' \</code>
24. <code>   f'<strong>\n</strong> Expected equal to {prompt_result_text=}.'</code>
25. <code> </code>

<h5>6.3.4.2 Переход на новую вкладку в браузере</h5>

При работе с веб-приложениями часто встречаются ссылки, которые открываются в новой вкладке браузера. Однако WebDriver
может одновременно взаимодействовать только с одной вкладкой браузера. Когда ссылка открывается в новой вкладке,
WebDriver продолжит работу на старой вкладке. Чтобы переключиться на только что открытую вкладку, нам нужно явно
указать, с какой вкладкой мы хотим работать. Этого можно добиться с помощью команды “switch_to.window”:
“browser.switch_to.window(window_name)”.

Чтобы определить имя вновь открытой вкладки, можно использовать метод “window_handles”, который возвращает массив имен
всех вкладок. Как только мы подтвердим, что две вкладки открыты, мы можем переключиться на вторую вкладку, используя
соответствующую индексацию: “new_window = browser.window_handles[1]“.

Давайте напишем тестовый сценарий страницы DEMOQA Browser Windows для открытия новой вкладки по нажатию по кнопке “New
Tab”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>new_tab_button_locator = (By.CSS_SELECTOR, '#tabButton')</code>
5. <code>sample_text_locator = (By.CSS_SELECTOR, '#sampleHeading')</code>
6. <code> </code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>browser_windows_page_link = 'https://demoqa.com/browser-windows'</code>
9. <code>browser.get(browser_windows_page_link)</code>
10. <code> </code>
11. <code>new_tab_button = browser.find_element(*new_tab_button_locator)</code>
12. <code>new_tab_button.click()</code>
13. <code> </code>
14. <code>browser.switch_to.window(browser.window_handles[1])</code>
15. <code> </code>
16. <code>sample_text_element = browser.find_element(*sample_text_locator)</code>
17. <code>actual_sample_text = sample_text_element.text</code>
18. <code>expected_sample_text = 'This is a sample page'</code>
19. <code> </code>
20. <strong><code>assert actual_sample_text == expected_sample_text, \</code></strong>
21. <code>   f'Expected {expected_sample_text=} in new tab ' \</code>
22. <code>   f'to be equal to {actual_sample_text=}.'</code>
23. <code> </code>

<h3>6.4 Настройка ожиданий</h3>

Разработчики усердно работали над созданием красивых и быстро загружаемых веб-страниц с плавными переходами между ними.

Это было достигнуто за счет использования подхода одностраничных приложений (SPA), когда сайт имеет только одну
страницу, а ее содержимое динамически обновляется с помощью JavaScript, который обменивается информацией с сервером
через REST API.

Хотя этот подход обеспечивает удобство работы с пользователем, он создает проблемы для тех, кто создает UI автотесты.
Непредсказуемое появление или исчезновение элементов на странице, непредсказуемое время рендеринга и изменение текста в
кнопках или сообщениях — вот некоторые особенности приложений SPA, которые необходимо учитывать при автотестировании.
Это один из самых сложных и запутанных аспектов разработки автотестов в Selenium (и других фреймворках для E-2-E (
end-to-end) тестов).

Мы рассмотрим эти распространенные проблемы и узнаем, как их преодолеть.

<h4>6.4.1 Работа методов get() и find_element()</h4>

Допустим, нам надо проверить, что на странице DEMOQA Dynamic Properties[^36] кнопку “Visible After 5 Seconds” можно
кликнуть.

Тестовый сценарий:

1. зайти на страницу;
2. кликнуть по кнопке.

Открываем страницу с помощью метода “get()”, ищем элемент методом “find_element()” и кликаем по кнопке с помощью метода
“click()”.

Вот как выглядит код автотеста:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
5. <code> </code>
6. <code>browser = webdriver.Chrome()</code>
7. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
8. <code>browser.get(dynamic_properties_page_link)</code>
9. <code> </code>
10. <code>visiable_after_five_sec_button = browser.find_element(*visiable_after_five_sec_button_locator)</code>
11. <code>visiable_after_five_sec_button.click()</code>
12. <code> </code>

Сперва попробуйте выполнить тест вручную, а затем переходите к автотесту. Когда вы будете проходить тест самостоятельно
вы заметите, что кнопка появляется с задержкой. И в случае запуска автотеста вы получите ошибку
“NoSuchElementException”, потому что автотест пытается найти кнопку, которая ещё не видна.

Такая ситуация часто происходит на страницах использующих JavaScript, что очень вероятно для современных сайтов.

<h4>6.4.2. Использование time.sleep()</h4>

Поскольку мы знаем о задержке появления кнопки, мы можем добавить паузу в наш тестовый сценарий перед поиском элемента.
Воспользуемся библиотекой “time”.

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
6. <code> </code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
9. <code>browser.get(dynamic_properties_page_link)</code>
10. <code> </code>
11. <code>sleep(5)</code>
12. <code>visiable_after_five_sec_button = browser.find_element(*visiable_after_five_sec_button_locator)</code>
13. <code>visiable_after_five_sec_button.click()</code>
14. <code> </code>

Текущее решение добавления фиксированной задержки перед поиском элемента может быть неэффективным при обработке
различных сценариев. Например, если элемент с сообщением тоже появляется с задержкой, или время задержки меняется при
появлении кнопки. Точно так же скорость Интернета на разных машинах может вызывать различия во временном интервале,
когда появляется кнопка. Хотя добавление задержки перед каждым действием может показаться решением, это непрактично, так
как может излишне увеличить время выполнения теста. С увеличением количества тестов эта проблема будет только
усугубляться.

<h4>6.4.3 Использование Selenium Waits (Implicit Waits)</h4>

Решение с time.sleep() плохое: оно не масштабируемое и трудно поддерживаемое.

Лучший способ справиться с ложными ошибками теста, вызванными асинхронным выполнением сценариев или задержками
сервера, — реализовать решение, которое ожидает появления определенного элемента на странице в течение заданного периода
времени (например, 5 секунд). Мы можем проверять наличие элемента каждые 500 миллисекунд, и как только элемент будет
найден, мы можем сразу перейти к следующему шагу теста. Таким образом, мы можем получить желаемый элемент как можно
скорее в лучшем случае или в течение 5 секунд в худшем случае.

Selenium WebDriver предоставляет особый подход к обработке этого ожидания, который позволяет нам установить ожидание во
время инициализации драйвера и применить его ко всем тестам. Это ожидание называется неявным ожиданием, поскольку нам не
нужно явно указывать его каждый раз, когда мы ищем элементы. Он будет автоматически применяться к каждой последующей
команде.

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
5. <code> </code>
6. <code>browser = webdriver.Chrome()</code>
7. <code>browser.implicitly_wait(5)</code>
8. <code> </code>
9. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
10. <code>browser.get(dynamic_properties_page_link)</code>
11. <code> </code>
12. <code>visiable_after_five_sec_button = browser.find_element(*visiable_after_five_sec_button_locator)</code>
13. <code>visiable_after_five_sec_button.click()</code>
14. <code> </code>

С неявным ожиданием, установленным во время инициализации драйвера, мы можем гарантировать, что наши тесты останутся
стабильными даже при незначительных задержках на веб-сайте. Для каждого экземпляра команды “find_element” WebDriver
будет ждать до 5 секунд, пока элемент появится на странице, прежде чем вызвать исключение “NoSuchElementException”.

<h4>6.4.4 Использование Explicit Waits (WebDriverWait и expected_conditions)</h4>

Для обеспечения надежности нашего теста мы должны убедиться, что наша кнопка не только появилась, но и является
кликабельной. На страницах часто бывает, что кнопки загружаются перед тем, как стать доступными для клика. Наш
предыдущий вариант теста с неявным ожиданием не будет дожидаться до активации элемента и тест упадет с ошибкой.

Давайте улучшим наш тест с использованием явных ожиданий и ожидаемых условий:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <strong><code>from selenium.webdriver.support.ui import WebDriverWait as wait</code></strong>
4. <strong><code>from selenium.webdriver.support import expected_conditions as EC</code></strong>
5. <code> </code>
6. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
7. <code> </code>
8. <code>browser = webdriver.Chrome()</code>
9. <code> </code>
10. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
11. <code>browser.get(dynamic_properties_page_link)</code>
12. <code> </code>
13. <code>visiable_after_five_sec_button = wait(browser, 5).until(</code>
14. <code>   EC.element_to_be_clickable(visiable_after_five_sec_button_locator))</code>
15. <code>visiable_after_five_sec_button.click()</code>
16. <code> </code>

Следует отметить, что “element_to_be_clickable()” вернёт элемент, когда он будет кликабельный или False в противном
случае.

Модуль “expected_conditions” имеет несколько других условий, которые можно использовать для определения ожиданий, с ними
можно ознакомиться в спецификации[^37].

<h2>Глава 7. Тестовые фреймворки</h2>

<h3>7.1 Тестирование web-приложений и тестовые фреймворки</h3>

Для начала нам необходимо познакомиться с распространенными тестовыми фреймворками unittest и Pytest. Это необходимо,
чтобы называть наши скрипты тестами. А главный атрибут теста - это сопоставление ожидаемого результата фактическому.

<h4>7.1.1 Автоматизированное и ручное тестирование</h4>

Чтобы писать хорошие автотесты необходимо понимать различия, сильные и слабые стороны ручного и автоматизированного
тестирования.

Таблица 1. Сравнение автоматизированного и ручного тестирования.


<table>
  <tr>
   <td><strong>Критерий</strong>
   </td>
   <td><strong>Ручное тестирование</strong>
   </td>
   <td><strong>Автоматизированное тестирование</strong>
   </td>
  </tr>
  <tr>
   <td>Тестовое покрытие
   </td>
   <td>Ограниченное тестовое покрытие из-за нехватки времени и ресурсов
   </td>
   <td>Полное тестовое покрытие может быть достигнуто с помощью больших наборов тестов
   </td>
  </tr>
  <tr>
   <td>Скорость выполнения
   </td>
   <td>Медленное выполнение и большая трудоемкость
   </td>
   <td>Более быстрое выполнение, экономия времени и усилий
   </td>
  </tr>
  <tr>
   <td>Человеческие ошибки
   </td>
   <td>Подвержены человеческим ошибкам
   </td>
   <td>Менее подвержены человеческим ошибкам
   </td>
  </tr>
  <tr>
   <td>Содержание
   </td>
   <td>Сценарии ручного тестирования требуют большего обслуживания и поддержки
   </td>
   <td>Сценарии автоматизированного тестирования требуют меньше обслуживания и поддержки
   </td>
  </tr>
  <tr>
   <td>Регрессионное тестирование
   </td>
   <td>Ручное регрессионное тестирование отнимает много времени и подвержено ошибкам
   </td>
   <td>Автоматизированное регрессионное тестирование эффективно и надежно
   </td>
  </tr>
  <tr>
   <td>Начальная стоимость и настройка окружения
   </td>
   <td>Низкие первоначальные затраты и время настройки
   </td>
   <td>Высокая начальная стоимость и время настройки
   </td>
  </tr>
  <tr>
   <td>Гибкость
   </td>
   <td>Более гибкие с точки зрения модификации тест-кейсов
   </td>
   <td>Менее гибкие с точки зрения модификации тест-кейсов
   </td>
  </tr>
  <tr>
   <td>Требования к навыкам
   </td>
   <td>Не требует специальных технических навыков
   </td>
   <td>Требуются специальные технические навыки
   </td>
  </tr>
  <tr>
   <td>Когда использовать
   </td>
   <td>При тестировании небольших изолированных функций или новых приложений
   </td>
   <td>При тестировании больших сложных систем с повторяющимися тестовыми сценариями
   </td>
  </tr>
</table>


Отметим, когда лучше использовать ручное тестирование:

* для исследовательского тестирования, когда тестирование основано на интуиции, творчестве и опыте, а не на заранее
  определенном наборе тест-кейсов;
* для тестирования удобства использования, когда основное внимание уделяется пользовательскому опыту и требуется
  обратная связь;
* для тестирования небольших изолированных функций или новых приложений, где тестовые наборы ограничены, а стоимость
  автоматизации высока;
* когда тестирование требует участия человека, например, тестирование пользовательского интерфейса или интуитивное (
  ad-hoc) тестирование.

Лучше использовать автоматизированное тестирование в следующих случаях:

* при тестировании больших и сложных систем с повторяющимися тест-кейсами;
* когда требуется регрессионное тестирование, чтобы убедиться, что новые изменения не нарушают существующую
  функциональность;
* когда требуется тестирование производительности или нагрузочное тестирование для имитации большого количества
  пользователей;
* когда требуется интеграционное тестирование, чтобы убедиться, что все компоненты системы работают без сбоев;
* при тестировании требуется высокая степень точности и согласованности, например, проверка данных или тестирование
  безопасности.

<h4>7.1.2 Структура автотеста</h4>

Основная структура тестирования как для модульных, так и UI автоматизированных тестов

может быть разбита на три части:

1. Test Setup: здесь подготавливаются среда и тестовые данные. В модульных тестах это может включать настройку фиктивных
   объектов(mocks) или заглушек для зависимостей, а в тестах пользовательского интерфейса — настройку веб-драйвера или
   эмулятора.
2. Test Execution: здесь выполняется фактическая тестовая логика. В модульных тестах это может включать вызов методов и
   проверку вывода, тогда как в тестах пользовательского интерфейса это может включать взаимодействие с элементами
   пользовательского интерфейса и проверку ожидаемого поведения.
3. Test Teardown: здесь выполняются любые действия по очистке. В модульных тестах это может включать сброс состояния
   любых фиктивных объектов, а в тестах пользовательского интерфейса это может включать закрытие веб-драйвера или
   эмулятора.

Несмотря на некоторые различия в деталях реализации модульных тестов и тестов пользовательского интерфейса, общая
структура тестов схожа. Оба типа тестов направлены на проверку функциональности приложения и обеспечение его правильного
поведения в различных сценариях.

Давайте обсудим, как именно можно производить проверки.

<h4>7.1.3 Проверка ожидаемого результата</h4>

Один из способов проверить ожидаемый результат — использовать встроенный оператор “assert” в Python. Этот оператор
оценивает достоверность утверждений, позволяя вам убедиться, что ваш код работает должным образом. Если ваше утверждение
истинно, никаких дополнительных сообщений генерироваться не будет. Однако, если утверждение ложно, будет выдано
исключение “AssertionError” с текстом, которое вы можете указать после проверки.

Посмотрим как работает “assert” на примере:

1. <code><em># Create a list of numbers</em></code>
2. <code>numbers = [1, 2, 3, 4, 5]</code>
3. <code> </code>
4. <code><em># Use the built-in sum() method to add up the numbers</em></code>
5. <code>total = sum(numbers)</code>
6. <code> </code>
7. <code><em># Assert that the total is 15</em></code>
8. <strong><code>assert total == 15, "The sum of the numbers is incorrect"</code></strong>
9. <code> </code>

В этом примере мы используем встроенный метод “sum()” для сложения чисел в списке чисел. Затем мы используем оператор
“assert”, чтобы проверить, что сумма чисел в списке равно 15, как мы ожидаем.

Если сумма не равна 15, оператор утверждения вызовет “AssertionError” и напечатает

сообщение "The sum of the numbers is incorrect".

Вы можете изменить числа в списке, чтобы проверка оказалась не выполнена и посмотреть на работу оператора “assert” в
этом случае.

Обратите внимание на то, что когда ваших тестов станет огромное количество вы уже не будете помнить, что конкретно
проверяет каждый тест. И фраза "Сумма чисел некорректна" не проясняет суть проблемы и вам придется тратить время, чтобы
понять что конкретно пошло не так.

Давайте попытаемся уменьшить степень неопределенности нашего теста:

1. <code><em># Create a list of numbers</em></code>
2. <code>numbers = [1, 2, 3, 4, 5]</code>
3. <code> </code>
4. <code><em># Use the built-in sum() method to add up the numbers</em></code>
5. <code>total = sum(numbers)</code>
6. <code> </code>
7. <code><em># Assert that the total is 100500</em></code>
8. <code>expected_sum = 100500</code>
9. <code> </code>
10. <strong><code>assert total == expected_sum, \</code></strong>
11. <code>   f"The sum of the list {numbers} is incorrect. " \</code>
12. <code>   f"Expected: {expected_sum}. Got: {total}."</code>
13. <code> </code>

Такой автотест легче поддерживать, если ожидаемая сумма чисел изменится в ходе разработки. Также нам сразу станет
очевидна суть проблемы, когда мы прочитаем сообщение об ошибке.

<h4>7.1.4 Тестовые сценарии</h4>

Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. Давайте
создадим файл “test_list_sum.py” и напишем в нём следующий код:

1. `"""Making first test scripts."""`
2. ` `
3. ` `
4. **<code>def test_sum_of_list_elements_equals_fifteen(input_list: list[int]) -> None:</code></strong>
5. <code>   """Testing that sum of list elements is equal to 15."""</code>
6. <code>   total = sum(input_list)</code>
7. <code>   <strong>assert</strong> total == 15, \</code>
8. <code>       f"The sum of the list {input_list} is incorrect. " \</code>
9. <code>       f"Expected: 15. Got: {total}."</code>
10. <code> </code>
11. <code> </code>
12. <strong><code>if __name__ == "__main__":</code></strong>
13. <code>   """This method works if started from that module."""</code>
14. <code>   numbers = [1, 2, 3, 4, 5]</code>
15. <code>   test_sum_of_list_elements_equals_fifteen(numbers)</code>
16. <code>   <strong>print</strong>("All tests passed!")</code>
17. <code> </code>

Тест-кейс помещен в отдельную функцию, чтобы можно было независимо к нему обращаться.

В этом файле мы вызываем функцию “test_sum_of_list_elements_equals_fifteen()” и передаём ей в качестве аргумента наш
список. Функция выполняет тестовый сценарий. Если тесты прошли успешно, то мы увидим в терминале выполнение команды
“print("All tests passed!")”.

Запустите тест и посмотрите как он работает. Попробуйте изменить входные данные так, чтобы тест провалился. Доработайте
тест, чтобы он выдавал достоверные данных в сообщении об ошибке при изменении входных параметров.

Добавим в файл “test_list_sum.py” ещё один тест и обратим внимание на поведение оператора “assert”: при провале любого
теста прекращается выполнение команд интерпретатором.

Добавим следующий код:

1. `"""Making first test scripts."""`
2. ` `
3. ` `
4. **<code>def test_sum_of_list_elements_equals_fifteen(input_list: list[int]) -> None:</code></strong>
5. <code>   """Test that sum of list elements is equal to 15."""</code>
6. <code>   total = sum(input_list)</code>
7. <code>   <strong>assert</strong> total == 15, \</code>
8. <code>       f"The sum of the list {input_list} is incorrect. " \</code>
9. <code>       f"Expected: 15. Got: {total}."</code>
10. <code> </code>
11. <code> </code>
12. <strong><code>def test_number_is_greater_than_five(number: int) -> None:</code></strong>
13. <code>   """Test that the number is greater than 5."""</code>
14. <code>   <strong>assert</strong> number > 5, \</code>
15. <code>       f"Number {number} is not greater than 5."</code>
16. <code> </code>
17. <code> </code>
18. <strong><code>if __name__ == "__main__":</code></strong>
19. <code>   """This method works if started from that module."""</code>
20. <code>   big_number = -191</code>
21. <code>   test_number_is_greater_than_five(big_number)</code>
22. <code>   numbers = [1, 2, 3, 4, 5]</code>
23. <code>   test_sum_of_list_elements_equals_fifteen(numbers)</code>
24. <code>   <strong>print</strong>("All tests passed!")</code>
25. <code> </code>

<h4>7.1.5 Выбор test runner</h4>

В предыдущих шагах мы научились писать простые тесты и запускать их с помощью Python. Запустите код из файла
“test_list_sum.py”, который мы написали в предыдущем шаге.

Обратите внимание на вывод в консоль:

1. `Traceback (most recent call last):`
2. ` File "C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum.py", line 21, in <module>`
3. `   test_number_is_greater_than_five(big_number)`
4. ` File "C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum.py", line 14, in test_number_is_greater_than_five`
5. `   assert number > 5, \`
6. `          ^^^^^^^^^^`
7. `AssertionError: Number -191 is not greater than 5.`

Рассмотрим минусы такого подхода к запуску автотестов:

* по мере роста количества тестов становится сложно изолировать и запускать только необходимые наборы тестов;
* чтобы выполнить каждый тест, вы должны подготовить тестовые данные и среду независимо друг от друга. Например, если вы
  хотите открывать и закрывать браузер для каждого теста, логика работы браузера должна быть воспроизведена в коде
  каждого отдельного теста;
* если тест завершается ошибкой из-за ошибки AssertionError, последующие тесты выполняться не будут. Следовательно,
  любые потенциальные проблемы в этих тестах останутся неизвестными до тех пор, пока неудачный тест не будет устранен
  или пока каждый тест не будет выполнен вручную по отдельности.

Чтобы упростить процесс написания и выполнения тестов, разработчики используют специализированные фреймворки, известные
как средства выполнения тестов (test runners).

Существует три основных тестовых фреймворка для Python: unittest, Pytest и Nose. Заметным преимуществом обладает модуль
unittest потому что он встроенный.

Между тем, Pytest и Nose предлагают расширенные функции, которые превосходят возможности unittest. Мы сначала кратко
рассмотрим использование unittest, а затем углубимся в возможности Pytest, который позволяет использовать более простой
тестовый код, чем unittest, и обеспечивает гибкое выполнение тестов. Кроме того, Pytest имеет обширную библиотеку
плагинов, которые могут решить практически любую проблему, связанную с автоматическим тестированием.

<h5>7.1.5.1 unittest</h5>

Тест-раннеры могут автоматически обнаруживать методы тестирования в указанных файлах при условии соблюдения стандартных
соглашений. Фундаментальное соглашение во всех средах тестирования заключается в том, что имя метода тестирования должно
начинаться со слова “test_”. Впоследствии может следовать любой текст для создания уникального имени теста:

1. **<code>def test_specific_meaningful_test_text():</code></strong>
2. <code>   <strong>pass</strong></code>
3. <code> </code>

Для unittest существуют собственные дополнительные правила:

* тесты обязательно должны находиться в специальном тестовом классе;
* вместо assert должны использоваться специальные “assertion” методы.

Давайте теперь изменим наши предыдущие тесты, чтобы их можно было запустить с помощью unittest. Для этого нам
понадобится выполнить следующие шаги:

1. импортировать unittest в файл: “import unittest”;
2. создать класс, который должен наследоваться от класса TestCase: “class TestWithUnittest(unittest.TestCase)”;
3. превратить тестовые функции в методы, добавив ссылку на экземпляр класса “self” в качестве первого аргумента функции:
   “def test_sum_of_list_elements_equals_fifteen(self, input_list: list[int]) -> None”;
4. изменить “assert” на “self.assertEqual()”;
5. заменить строку запуска программы на “unittest.main()”.
1. `"""Making first test scripts."""`
2. **<code>import unittest</code></strong>
3. <code> </code>
4. <code> </code>
5. <strong><code>class TestWithUnittest(unittest.TestCase):</code></strong>
6. <code>   """Test class must be inherited from TestCase."""</code>
7. <code>   big_number = -191</code>
8. <code>   numbers = [1, 2, 3, 4, 5]</code>
9. <code> </code>
10. <code>   <strong>def</strong> test_sum_of_list_elements_equals_fifteen(self) -> None:</code>
11. <code>       """Test that sum of list elements is equal to 15."""</code>
12. <code>       input_list = self.numbers</code>
13. <code>       total = sum(input_list)</code>
14. <code>       self.assertEqual(total, 15, \</code>
15. <code>                        f"The sum of the list {input_list} is incorrect. " \</code>
16. <code>                        f"Expected: 15. Got: {total}.")</code>
17. <code> </code>
18. <code>   <strong>def</strong> test_number_is_greater_than_five(self) -> None:</code>
19. <code>       """Test that the number is greater than 5."""</code>
20. <code>       number = self.big_number</code>
21. <code>       self.assertTrue(number > 5, \</code>
22. <code>                       f"Number {number} is not greater than 5.")</code>
23. <code> </code>
24. <code> </code>
25. <strong><code>if __name__ == "__main__":</code></strong>
26. <code>   """This method works if started from that module."""</code>
27. <code>   unittest.main()</code>
28. <code>   <strong>print</strong>("All tests passed!")</code>
29. <code> </code>

После изменений запустим нам тест с помощью Python:

```
Ran 2 tests in 0.005s

FAILED (failures=1)

Failure
Traceback (most recent call last):
 File "C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum_unittest.py", line 21, in test_number_is_greater_than_five
   self.assertTrue(number > 5, \
AssertionError: False is not true : Number -191 is not greater than 5.
```

Теперь мы видим более подробную информацию о результатах запуска: было запущено два теста, один тест выполняется с
ошибкой. Место ошибки и пояснение к ней отображаются в логе.

<h3>7.2 Тестирование с помощью Pytest</h3>

<h4>7.2.1 Pytest - преимущества и недостатки</h4>

Установить Pytest можно использовав команду: “pip install pytest”.

Рассмотрим преимущества использования Pytest .

1. Простой и удобный в использовании: Pytest разработан, чтобы быть интуитивно понятным и простым в использовании, с
   простым синтаксисом для определения тестов и фикстур.
2. Мощные фикстуры: фикстуры в Pytest — это мощный инструмент для настройки тестовых данных и ресурсов, и их можно
   использовать в тестах и наборах тестов.
3. Полная отчетность: Pytest предоставляет подробные и исчерпывающие отчеты о результатах тестирования, включая сводки,
   информацию о трассировке и продолжительность тестирования.
4. Параметризованное тестирование. С помощью Pytest вы можете легко выполнять параметризованное тестирование, когда одна
   тестовая функция запускается с несколькими наборами входных данных.
5. Система плагинов: Pytest имеет богатую систему плагинов, которая предоставляет широкий спектр функций, таких как
   параллельный запуск тестов, создание отчетов в формате HTML и многое другое.
6. Поддерживает как модульное, так и функциональное тестирование: Pytest поддерживает как модульное, так и
   функциональное тестирование, что делает его универсальным инструментом для тестирования всех типов кода Python.
7. Лучшее обнаружение тестов: Pytest обеспечивает лучшее обнаружение тестов, чем unittest, который может автоматически
   находить и запускать тесты в каталоге или модуле, не требуя явных тест-кейсов.

В целом, Pytest — это мощный и гибкий инструмент тестирования, который обеспечивает множество преимуществ по сравнению с
unittest, включая более простой синтаксис, более мощные инструменты, улучшенную отчетность и большую расширяемость.

Хотя у Pytest есть много преимуществ, есть и некоторые недостатки, которые следует учитывать при его использовании.

1. Кривая обучения: Pytest имеет более обширный набор функций и требует некоторых дополнительных знаний по сравнению со
   встроенным модулем unittest. Это может затруднить обучение новичков.
2. Настройка: гибкость Pytest может быть палкой о двух концах. Его широкие возможности настройки могут затруднить для
   команд поддержание согласованности в наборах тестов.
3. Управление плагинами: Pytest имеет большое количество доступных плагинов, что может быть как силой, так и слабостью.
   Хотя они предлагают множество полезных функций, управление плагинами может занимать много времени, и может быть
   сложно найти и выбрать правильный плагин для ваших нужд.
4. Отладка: отладка может быть сложной задачей в Pytest из-за его модульной природы. Иногда может быть сложно
   определить, какой плагин или хук вызывает проблему, что приводит к увеличению времени отладки.
5. Накладные расходы: дополнительные функции и гибкость Pytest сопряжены с некоторыми накладными расходами. В некоторых
   случаях тесты Pytest могут выполняться дольше, чем тесты, написанные с использованием более простых сред
   тестирования.

При рассмотрении вопроса о том, является ли Pytest правильным выбором для вашего проекта, важно взвесить эти недостатки
и преимущества.

<h4>7.2.2 Фиксация пакетов</h4>

Файл “requirements.txt” — это текстовый файл, в котором вы можете перечислить необходимые пакеты Python с их версиями.

Распространенной практикой является использование файла “requirements.txt”, чтобы сделать ваш проект более переносимым и
чтобы любой, кто хочет запустить ваш код, могли легко установить все зависимости.

Когда вы создаете файл “requirements.txt”, вы можете перечислить все пакеты Python, необходимые для запуска вашего
проекта. Вы можете указать версию каждого пакета или использовать диапазоны версий, чтобы указать, что любая версия в
пределах определенного диапазона будет приемлемой.

Чтобы создать файл “requirements.txt” для вашего проекта Python, выполните следующие действия:

1. откройте командную строку или окно терминала;
2. перейдите в каталог вашего проекта;
3. убедитесь, что ваша виртуальная среда активна;
4. выполните следующую команду, чтобы создать файл “requirements.txt”: “pip freeze > requirements.txt”.

Это создаст новый файл с именем “requirements.txt” в каталоге вашего проекта. Файл будет содержать список всех
установленных пакетов и их версий.

Если вы используете виртуальные среды, рекомендуется создать новый файл требований после установки нового пакета или
обновления существующего. Это гарантирует наличие актуального списка зависимостей, которые можно легко установить в
других средах.

Чтобы установить зависимости из файла “requirements.txt” нужно использовать команду: “pip install -r requirements.txt”.

Все необходимые зависимости установлены одной командой!

<h4>7.2.3 Pytest: правила запуска тестов</h4>

Мы кратко остановимся на важнейших функциях запуска тестов с использованием Pytest.

Когда мы инициируем команду “pytest”, средство запуска тестов соберет все тесты для выполнения на основе определенных
правил.

* Если мы выполним команду “pytest” без передачи каких-либо аргументов, средство запуска тестов автоматически выполнит
  поиск тестов в текущем каталоге.
* В качестве аргумента вы можете передать файл, путь к каталогу или любую комбинацию каталогов и файлов.

Например:

pytest scripts/selenium_scripts - найти все тесты в директории “scripts/selenium_scripts”;

pytest test_user_interface.py - найти и выполнить все тесты в файле;

pytest scripts/drafts.py::test_register_new_user_parametrized - найти тест с именем
“test_register_new_user_parametrized” в указанном файле в указанной директории и выполнить.

* Далее Pytest выполнит рекурсивный поиск по всем вложенным каталогам.
* Во время поиска Pytest проверяет все каталоги на наличие файлов, которые соответствуют соглашению об именах “test_*
  .py” или “*test.py” (т. е. файлы, которые начинаются с “test_” или заканчиваются на “_test” и имеют расширение “.py”).
* В каждом из этих файлов Pytest идентифицирует тестовые функции на основе следующих правил:

1. Pytest идентифицирует все тесты, которые находятся за пределами классов и имена которых начинаются с “test”;
2. кроме того, Pytest идентифицирует все тесты в классах, имена которых начинаются с “Test” (и которые не содержат метод
   инициализации) и имена методов которых начинаются с “test”.

Рекомендую изучить соглашение по обнаружению тестов[^38].

<h4>7.2.4 Pytest - отчёты</h4>

Давайте сравним формат отчётов unittest и Pytest.



<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image15.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image15.png "image_tooltip")

Рисунок 15. Отчёт сформированный unittest.



<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image16.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image16.png "image_tooltip")

Рисунок 16. Отчёт сформированный Pytest.

При выполнении Pytest с флагом -v (verbose, подробный) отчет о тестировании включает дополнительную информацию, в
которой перечислены тесты и их статус прохождения/непрохождения. Кроме того вы можете ознакомиться с другими полезными
командами и функциями pytest использовав команду “pytest --help”.

<h4>7.2.5 Pytest - как пишут тесты.</h4>

В отличие от unittest, Pytest не требует использования дополнительных специфических конструкций в ваших тестах.

Мы уже запускали тесты, написанные в unittest стиле с помощью Pytest. Давайте перепишем их в более простом варианте,
который понимает Pytest.

Назовем новый файл “test_sum_and_value.py”.

1. `"""Making first test scripts."""`
2. ` `
3. ` `
4. **<code>class TestWithPytest:</code></strong>
5. <code>   """This class provides data for tests."""</code>
6. <code>   big_number: int = -191</code>
7. <code>   numbers: list[int] = [1, 2, 3, 4, 5]</code>
8. <code> </code>
9. <code>   <strong>def</strong> test_sum_of_list_elements_equals_fifteen(self) -> None:</code>
10. <code>       """Test that sum of list elements is equal to 15."""</code>
11. <code>       input_list = self.numbers</code>
12. <code>       total = sum(input_list)</code>
13. <code>       <strong>assert</strong> total == 15, \</code>
14. <code>           f"The sum of the list {input_list} is incorrect. " \</code>
15. <code>           f"Expected: 15. Got: {total}."</code>
16. <code> </code>
17. <code>   <strong>def</strong> test_number_is_greater_than_five(self) -> None:</code>
18. <code>       """Test that the number is greater than 5."""</code>
19. <code>       number = self.big_number</code>
20. <code>       <strong>assert</strong> number > 5, \</code>
21. <code>           f"Number {number} is not greater than 5."</code>
22. <code> </code>

Запустите тест с помощью команды “pytest test_sum_and_value.py” и посмотрите на формирование отчёта.

Результат должен быть такой: 1 тест пройден, 1 тест провален.

<h3>7.3 Использование фикстур в Pytest</h3>

<h4>7.3.1 Классические фикстуры</h4>

В контексте Pytest фикстуры — это вспомогательные функции для тестов, которые существуют вне самого тестового сценария.

Фикстуры служат различным целям, включая подготовку тестовой среды, очистку тестовой среды и данных после завершения
теста, подключение к базам данных, создание тестовых файлов и подготовку данных в текущей среде с использованием методов
API. Вы можете ознакомиться со статьёй о фикстурах в разработке программного обеспечения[^39].

Традиционный подход к использованию фикстур предполагает создание методов “setup()” и “teardown()” в тестовом файле. Вы
можете найти более подробную информацию о том, как использовать эти методы в документации Pytest[^40].

Фикстуры часто создаются для определённых областей видимости, таких как модули, классы и функции, чтобы избежать
повторения кода и переиспользовать его.

Давайте создадим фикстуры для инииализации браузера и его закрытия и сгруппируем тесколько тестов в тестовые наборы.

Затем рассмотрим два примера, на которых рассмотрим два разных подхода к использованию фикстур. В первом примере мы
будем создавать один экземпляр браузера для тестового набора, а во втором примере - создавать по экземпляру браузера для
каждого теста.

Давайте назовём наш файл “test_fixture1.py”, запускать который мы будем командой “pytest -s test_fixture1.py”, чтобы
видеть вывод “print()” в консоль.

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>link = 'https://demoqa.com/'</code>
5. <code> </code>
6. <code> </code>
7. <strong><code>class TestMainPage1:</code></strong>
8. <code> </code>
9. <code>   @classmethod</code>
10. <code>   <strong>def</strong> setup_class(cls):</code>
11. <code>       <strong>print</strong>('<strong>\n</strong>start browser for test suite..')</code>
12. <code>       cls.browser = webdriver.Chrome()</code>
13. <code> </code>
14. <code>   @classmethod</code>
15. <code>   <strong>def</strong> teardown_class(cls):</code>
16. <code>       <strong>print</strong>('quit browser for test suite..')</code>
17. <code>       cls.browser.quit()</code>
18. <code> </code>
19. <code>   <strong>def</strong> test_guest_should_see_banner_image(self):</code>
20. <code>       self.browser.get(link)</code>
21. <code>       self.browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
22. <code> </code>
23. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self):</code>
24. <code>       self.browser.get(link)</code>
25. <code>       self.browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
26. <code> </code>
27. <code> </code>
28. <strong><code>class TestMainPage2:</code></strong>
29. <code> </code>
30. <code>   <strong>def</strong> setup_method(self):</code>
31. <code>       <strong>print</strong>('start browser for test..')</code>
32. <code>       self.browser = webdriver.Chrome()</code>
33. <code> </code>
34. <code>   <strong>def</strong> teardown_method(self):</code>
35. <code>       <strong>print</strong>('quit browser for test..')</code>
36. <code>       self.browser.quit()</code>
37. <code> </code>
38. <code>   <strong>def</strong> test_guest_should_see_banner_image(self):</code>
39. <code>       self.browser.get(link)</code>
40. <code>       self.browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
41. <code> </code>
42. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self):</code>
43. <code>       self.browser.get(link)</code>
44. <code>       self.browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
45. <code> </code>

Обратите внимание на количество запусков браузера в первом тестовом наборе и во втором. В первом наборе браузер
запустился один раз, а во втором - дважды.

Запуск каждого теста в отдельном экземпляре браузера считается хорошей практикой, хоть и увеличивающей продолжительность
прохождения тестов, но повышающей стабильность прохождения тестов, так как убирается взаимное влияние тестовых сценариев
друг на друга.

В настоящее время используются более гибкие к применению фикстуры “@pytest.fixture”.

<h4>7.3.2 Фикстуры, возвращающие значение</h4>

Pytest предоставляет расширенный подход к фикстурам, где их можно определять глобально, передавать в качестве аргументов
тестовым методам и даже включать в себя набор предварительно созданных фикстур. Этот подход гораздо более гибкий и
удобный для работы со вспомогательными функциями, и мы сейчас рассмотрим его более подробно.

Давайте рассмотрим предыдущий пример, используя фикстуры Pytest. Мы можем создать фикстуру с именем “browser”, которая
инициализирует объект WebDriver и возвращает его для использования в тестах.

Чтобы определить фикстуру, нам нужно создать метод с именем “browser” и декорировать его “@pytest.fixture”. После
определения мы можем вызвать фикстуру в наших тестах, передав ее в качестве параметра. По умолчанию для каждого
тестового метода создается фикстура, а это

значит, что для каждого теста будет запускаться отдельный экземпляр браузера.

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture</code>
9. <strong><code>def browser():</code></strong>
10. <code>   <strong>print</strong>('<strong>\n</strong>start browser for test')</code>
11. <code>   browser = webdriver.Chrome()</code>
12. <code>   <strong>return</strong> browser</code>
13. <code> </code>
14. <code> </code>
15. <strong><code>class TestMainPage1:</code></strong>
16. <code>   <em># вызываем фикстуру в тесте, передав ее как параметр</em></code>
17. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
18. <code>       browser.get(link)</code>
19. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
20. <code> </code>
21. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
22. <code>       browser.get(link)</code>
23. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
24. <code> </code>

<h4>7.3.3 Финализаторы, закрываем браузер</h4>

При выполнении тестов крайне важно закрывать экземпляры браузера. Одно правило из дзена Python[^41] гласит: “Явное лучше
неявного” и не стоит всегда надеяться на сборщика мусора Python, а закрывать браузер самостоятельно.

Один из способов это сделать - использовать стандартный оператор “yield” языка Python. После завершения теста,
вызвавшего фикстуру, выполнение фикстуры продолжается со строки, следующей за строкой с ключевым словом “yield”.

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture</code>
9. <strong><code>def browser():</code></strong>
10. <code>   <strong>print</strong>('<strong>\n</strong>start browser')</code>
11. <code>   browser = webdriver.Chrome()</code>
12. <code>   <strong>yield</strong> browser</code>
13. <code>   <strong>print</strong>('<strong>\n</strong>quit browser')</code>
14. <code>   browser.quit()</code>
15. <code> </code>
16. <code> </code>
17. <strong><code>class TestMainPage1:</code></strong>
18. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
19. <code>       browser.get(link)</code>
20. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
21. <code> </code>
22. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
23. <code>       browser.get(link)</code>
24. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
25. <code> </code>

Вы также можете добавить финализатор согласно документации Pytest, использовав метод “addfinalizer()”[^42].

<h4>7.3.4 Область видимости</h4>

Фикстуры в PyTest могут быть привязаны к определенной области покрытия. Доступные значения для параметра области
действия: “функция”, “класс”, “модуль” и “сеанс”. В зависимости от выбранной области фикстура будет вызываться один раз
для каждой тестовой функции, один раз для каждого тестового класса, один раз для каждого тестового модуля или один раз
для всего тестового сеанса.

Чтобы сэкономить время, мы можем установить область действия фикстуры браузера на “класс”, чтобы все тесты из класса
“TestMainPage1” могли выполняться в одном и том же браузере.

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture(scope='class')</code>
9. <strong><code>def browser():</code></strong>
10. <code>   <strong>print</strong>('<strong>\n</strong>start browser')</code>
11. <code>   browser = webdriver.Chrome()</code>
12. <code>   <strong>yield</strong> browser</code>
13. <code>   <strong>print</strong>('<strong>\n</strong>quit browser')</code>
14. <code>   browser.quit()</code>
15. <code> </code>
16. <code> </code>
17. <strong><code>class TestMainPage1:</code></strong>
18. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
19. <code>       browser.get(link)</code>
20. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
21. <code> </code>
22. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
23. <code>       browser.get(link)</code>
24. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
25. <code> </code>

В этом примере запустился один экземпляр браузера и тесты были проведены в нём последовательно друг за другом.
Использовать такой подход к исполнению тестов не рекомендуется, кроме исполнения очень длительных тестов, как правило
связанных с базами данных.

<h4>7.3.5 Автоиспользование фикстур</h4>

Вы можете указать дополнительный параметр при определении фикстуры, а именно “autouse=True”, что означает, что фикстура
будет автоматически выполняться для каждого теста, не требуя явного вызова. Однако вы должны использовать этот параметр
с осторожностью, так как фикстура будет выполняться для всех тестов. Поэтому рекомендуется использовать его только
тогда, когда это необходимо.

<h3>7.4 Pytest - маркировка</h3>

<h4>7.4.1 Маркировка тестов часть первая</h4>

При работе с большим количеством тестов может быть полезно распределить их по категориям, а не только по именам. Вот где
вступает в действие маркировка тестов. Отмечая тесты определенными категориями, такими как “smoke” для критических
тестов или “regression” для регрессионных тестов, выполняемых перед выпуском, мы можем выборочно запускать тесты на
основе их категории. Кроме того, у нас могут быть тесты, специфичные для определенного браузера, например Opera, и мы
можем захотеть запустить эти тесты только в этом браузере.

PyTest предоставляет тестовую маркировку или метки для этой цели. Чтобы пометить тест, вы можете использовать декоратор,
например “@pytest.mark.mark_name”, где “mark_name” — любая выбранная вами строка.

Разделим тесты в одном из предыдущих примеров на “smoke” и “regression”.

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture(scope='function')</code>
9. <strong><code>def browser():</code></strong>
10. <code>   <strong>print</strong>('<strong>\n</strong>start browser')</code>
11. <code>   browser = webdriver.Chrome()</code>
12. <code>   <strong>yield</strong> browser</code>
13. <code>   <strong>print</strong>('<strong>\n</strong>quit browser')</code>
14. <code>   browser.quit()</code>
15. <code> </code>
16. <code> </code>
17. <strong><code>class TestMainPage1:</code></strong>
18. <code>   @pytest.mark.smoke</code>
19. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
20. <code>       <strong>print</strong>('smoke test')</code>
21. <code>       browser.get(link)</code>
22. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
23. <code> </code>
24. <code>   @pytest.mark.regression</code>
25. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
26. <code>       <strong>print</strong>('regression test')</code>
27. <code>       browser.get(link)</code>
28. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
29.

Вы можете выполнить тест с нужной меткой, передав параметр “-m”, а затем нужную метку в командной строке: “pytest -s -v
-m smoke test_fixture8.py”

Должен запуститься тест с маркировкой “smoke”. При этом вы увидите уведомление с предупреждением, что используемая метка
не зарегистрирована. Рекомендуется всегда регистрировать метки, чтобы избежать опечаток при вызове определённых тестов.

<h4>7.4.2 Как регистрировать метки?</h4>

Создайте файл “pyproject.toml” в корневой директории вашего тестового проекта и добавьте в файл следующие строки:

1. `[tool.pytest.ini_options]`
2. ` `
3. `markers = [`
4. `   "smoke: marker for smoke tests",`
5. `   "regression: marker for regression tests"`
6. `]`

Запустите тесты повторно, предупреждений быть не должно.

Маркировать можно не только методы, но и сразу целые классы. В этом случае маркировка будет применена ко всем тестовым
методам этого класса.

<h4>7.4.3 Маркировка тестов часть вторая</h4>

<h5>7.4.3.1 Инверсия</h5>

Можно использовать логическую инверсию для запуска тестов помеченных не как “smoke”: “pytest -m "not smoke"
test_fixture8.py”.

<h5>7.4.3.2 Объединение тестов с разной маркировкой</h5>

Чтобы запустить тесты с разными маркировками необходимо использовать логическое ИЛИ, например для запуска тестов с
маркировкой “smoke” и “regression”: “pytest -s -v -m "smoke or regression" test_fixture8.py”.

<h5>7.4.3.3 Запуск тестов, имеющих несколько маркировок</h5>

Допустим, у вас есть несколько дымовых тестов для определённой операционной системы и вам необходимо запустить только
их. Для этого вы должны маркировать тесты, которые вы хотите запустить на конкретной ОС соответствующей маркировкой. И
не забываем регистрировать новые метки.

1. `[tool.pytest.ini_options]`
2. ` `
3. `markers = [`
4. `   "smoke: marker for smoke tests",`
5. `   "regression: marker for regression tests",`
6. `   "win10"`
7. `]`
1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture(scope='function')</code>
9. <strong><code>def browser():</code></strong>
10. <code>   <strong>print</strong>('<strong>\n</strong>start browser')</code>
11. <code>   browser = webdriver.Chrome()</code>
12. <code>   <strong>yield</strong> browser</code>
13. <code>   <strong>print</strong>('<strong>\n</strong>quit browser')</code>
14. <code>   browser.quit()</code>
15. <code> </code>
16. <code> </code>
17. <strong><code>class TestMainPage1:</code></strong>
18. <code>   @pytest.mark.smoke</code>
19. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
20. <code>       <strong>print</strong>('smoke test 1')</code>
21. <code>       browser.get(link)</code>
22. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
23. <code> </code>
24. <code>   @pytest.mark.smoke</code>
25. <code>   @pytest.mark.win10</code>
26. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
27. <code>       <strong>print</strong>('smoke test 2')</code>
28. <code>       browser.get(link)</code>
29. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
30. <code> </code>

Чтобы запустить только smoke-тесты для Windows 10, нужно использовать логическое И: “pytest -s -v -m "smoke and win10"
test_fixture81.py”.

<h4>7.4.4 Пропуск тестов</h4>

PyTest предоставляет встроенные маркеры, которые позволяют пропустить тест во время сбора тестов. Вам не нужно объявлять
эти маркеры в “pyproject.toml”.

Чтобы пропустить тест необходимо отметить его как “@pytest.mark.skip”:

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture(scope='function')</code>
9. <strong><code>def browser():</code></strong>
10. <code>   <strong>print</strong>('<strong>\n</strong>start browser')</code>
11. <code>   browser = webdriver.Chrome()</code>
12. <code>   <strong>yield</strong> browser</code>
13. <code>   <strong>print</strong>('<strong>\n</strong>quit browser')</code>
14. <code>   browser.quit()</code>
15. <code> </code>
16. <code> </code>
17. <strong><code>class TestMainPage1:</code></strong>
18. <code>   @pytest.mark.skip(reason='Reason to skip test')</code>
19. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
20. <code>       browser.get(link)</code>
21. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
22. <code> </code>
23. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
24. <code>       browser.get(link)</code>
25. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
26. <code> </code>

Хорошей практикой является явное указание причины пропуска теста “@pytest.mark.skip(reason="Reason to skip test")”.

Команда для отображения всех зарегистрированных меток: “pytest --markers”.

<h4>7.4.5 XFail: отметить тест как ожидаемо падающий</h4>

Давайте включим тест в наш тестовый класс, который проверяет, присутствует ли кнопка “JOIN NOW”.

Допустим, должна быть кнопка “JOIN NOW”, но из-за недавних изменений кода ее больше нет. Ожидая, пока разработчики
исправят проблему, мы по-прежнему хотим, чтобы все наши тесты прошли успешно, но мы хотим, чтобы неудачный тест был
помечен соответствующим образом, чтобы мы могли не забыть проверить его позже. Поэтому давайте добавим маркер

“@pytest.mark.xfail” к проваленному тесту.

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>link = 'https://demoqa.com/'</code>
6. <code> </code>
7. <code> </code>
8. <code>@pytest.fixture(scope='function')</code>
9. <strong><code>def browser():</code></strong>
10. <code>   browser = webdriver.Chrome()</code>
11. <code>   <strong>yield</strong> browser</code>
12. <code>   browser.quit()</code>
13. <code> </code>
14. <code> </code>
15. <strong><code>class TestMainPage1:</code></strong>
16. <code>   <strong>def</strong> test_guest_should_see_banner_image(self, browser):</code>
17. <code>       browser.get(link)</code>
18. <code>       browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
19. <code> </code>
20. <code>   <strong>def</strong> test_guest_should_see_elements_card_on_the_main_page(self, browser):</code>
21. <code>       browser.get(link)</code>
22. <code>       browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
23. <code> </code>
24. <code>   @pytest.mark.xfail(reason="fixing this bug right now")</code>
25. <code>   <strong>def</strong> test_guest_should_see_join_now_button_on_the_main_page(self, browser):</code>
26. <code>       browser.get(link)</code>
27. <code>       browser.find_element(By.ID, 'join_now')</code>
28. <code> </code>

Запустите тесты командой: “pytest -v test_fixture10.py”.

Если ошибка устранена, тест, отмеченный “@pytest.mark.xfail”, теперь будет помечен как “XPASS” (неожиданно пройденный).
На этом этапе можно удалить отметку “xfail”. Кроме того, к отметке “xfail” можно добавить параметр “reason”. Чтобы
просмотреть это сообщение в консоли, во время запуска необходимо добавить параметр “pytest -rx”.

Дополнительно об использовании меток об неожиданном прохождении или падении вы можете прочитать в документации[^43].

<h3>7.5 Pytest - параметризация, конфигурирование, плагины</h3>

<h4>7.5.1 Conftest.py - конфигурирование тестов</h4>

В предыдущем разделе мы создали фикстуру браузера “browser”, которая создает экземпляр браузера для тестирования в
текущем файле.

Однако, когда у нас есть несколько тестовых файлов, может быть неудобно переопределять эту фикстуру в каждом файле.

Чтобы избежать этого повторения и сохранить часто используемые фикстуры и глобальные настройки, мы можем использовать
файл “conftest.py”, который должен находиться в каталоге верхнего уровня нашего тестового проекта.

Хотя можно создавать дополнительные файлы “conftest.py” в других каталогах, любые настройки, определенные в этих файлах,
будут применяться только к тестам в подкаталогах.

Мы можем создать файл “conftest.py” в каталоге верхнего уровня нашего тестового проекта и переместить туда фикстуру
браузера для хранения часто используемых фикстур и глобальных настроек. Благодаря этому файл с тестами становится более
лаконичным.

conftest.py:

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <code> </code>
4. <code> </code>
5. <code>@pytest.fixture(scope='function')</code>
6. <strong><code>def browser():</code></strong>
7. <code>   browser = webdriver.Chrome()</code>
8. <code>   <strong>yield</strong> browser</code>
9. <code>   browser.quit()</code>
10. <code> </code>

С добавлением файла “conftest.py” в корневой каталог тестового проекта доступ к фикстуре браузера теперь возможен для
всех тестовых файлов.

Фикстура передается тестовому методу в качестве аргумента, что позволяет легко повторно использовать вспомогательные
функции в разных частях проекта, независимо от того, сколько тестовых файлов создано.

1. **<code>from selenium.webdriver.common.by import By</code></strong>
2. <code> </code>
3. <code>link = 'https://demoqa.com/'</code>
4. <code> </code>
5. <code> </code>
6. <strong><code>def test_guest_should_see_banner_image(browser):</code></strong>
7. <code>   browser.get(link)</code>
8. <code>   browser.find_element(By.CSS_SELECTOR, '.banner-image')</code>
9. <code> </code>

Крайне важно понять важный аспект поведения файлов конфигурации. Pytest автоматически обнаруживает и загружает файлы
“conftest.py” в каталог с тестами. Если у вас все тестовые сценарии в одной папке, будьте осторожны и не запускайте
тесты из папки с тестами, так как это может помешать автоматическому обнаружению файлов “conftest.py”:

```
tests/
├── conftest.py
├── subfolder
│   └── conftest.py
│   └── test_abs.py

следует избегать!
```

Если тесты запускаются из каталога, содержащего два файла “conftest.py”, будут применены оба файла, что может привести к
непредвиденным ошибкам и конфликтам.

Этот метод можно использовать для переопределения различных фикстур, но для знакомства рекомендуется придерживаться
одного файла для каждого проекта/задачи и сохранять их в горизонтальном порядке, например:

```
selenium_course_solutions/
├── section3
│   └── conftest.py
│   └── test_languages.py
├── section4
│   └── conftest.py
│   └── test_main_page.py

правильно!
```

Подробнее можете ознакомиться в документации[^44].

<h4>7.5.2 Параметризация тестов</h4>

Используя декоратор “@pytest.mark.parametrize()” в Pytest, вы можете запустить один и тот же тест с различными входными
параметрами. Например, предположим, что наш веб-сайт доступен на разных языках. Мы можем написать тест, который
проверяет, отображается ли ссылка на форму входа для русской и английской версий главной страницы сайта. Мы можем

передать в наш тест ссылки на русскую и английскую версии главной страницы сайта.

Чтобы использовать декоратор “@pytest.mark.parametrize()”, вам необходимо указать параметр, который необходимо изменить,
и список значений параметров. Тест также должен передавать параметр в качестве аргумента. Важно отметить, что при
использовании декоратора имя параметра заключается в кавычки, а в списке тестовых аргументов кавычки не нужны.

Далее мы немного поработаем с сайтом Oscar - Sandbox[^45].

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code> </code>
6. <code>@pytest.fixture(scope='function')</code>
7. <strong><code>def browser():</code></strong>
8. <code>   browser = webdriver.Chrome()</code>
9. <code>   <strong>yield</strong> browser</code>
10. <code>   browser.quit()</code>
11. <code> </code>
12. <code> </code>
13. <code>@pytest.mark.parametrize('language', ['ru', 'en-gb'])</code>
14. <strong><code>def test_guest_should_see_login_link(browser, language):</code></strong>
15. <code>   link = f'http://selenium1py.pythonanywhere.com/{language}/'</code>
16. <code>   browser.get(link)</code>
17. <code>   browser.find_element(By.CSS_SELECTOR, '#login_link')</code>
18. <code> </code>

Запустите тест командой “pytest -v test_fixture7.py”.

Вы увидите, что запустилось два теста с разным параметром, заключённым в квадратные скобки. Параметризация помогает
запускать тесты с большим количеством входных данных в одном сценарии без дублирования кода.

Можно параметризировать не только функции, но и целые классы. В таком случае параметры будут использованы для всех
функций, которые расположены внутри класса.

Дополнительно ознакомьтесь с документацией о том как правильно использовать параметризацию в Pytest[^46].

<h4>7.5.3 Установка Firefox и Selenium-драйвера geckodriver</h4>

До сих пор мы выполняли наши тесты только в браузере Chrome. Однако что, если мы хотим протестировать наше
веб-приложение и в других браузерах? В таком сценарии мы можем запускать одни и те же тесты в разных браузерах, указав
имя браузера при запуске тестов. Например, мы можем выбрать Firefox в качестве второго браузера, поскольку он широко
используется и может работать на любой платформе. Чтобы запустить тесты в конкретном браузере, нам нужно указать
параметр “browser_name” при запуске с помощью следующей команды: “pytest -s -v --browser_name=firefox test_cmd.py”.

Установите последнюю версию браузера Firefox[^47] для вашей платформы.

Selenium-драйвер для браузера Firefox называется geckodriver, его вам стоит скачать из официального репозитория[^48]
компании Mozilla. Ознакомьтесь с инструкцией по установке драйвера[^49], если у вас возникнут сложности.

<h4>7.5.4 Conftest.py и передача параметров в командной строке</h4>

На этом этапе мы разберемся, как настраивать тестовые среды, передавая параметры через командную строку с помощью
встроенной фикстуры “request”, которая может получать данные о текущем выполняемом тесте. Это может позволить нам
хранить дополнительные данные в отчете и выполнять ряд других полезных задач.

Это делается с помощью встроенной функции “pytest_addoption()” и фикстуры “request”. Сначала добавляем в файле
“conftest.py” обработчик опции в функции “pytest_addoption()”, затем напишем фикстуру, которая будет обрабатывать
переданные в опции данные.

Подробности использования можно узнать в документации[^50].

Добавим логику обработки командной строки в файл “conftest.py”.

1. **<code>import pytest</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <code> </code>
4. <code> </code>
5. <strong><code>def pytest_addoption(parser):</code></strong>
6. <code>   parser.addoption('--browser_name', action='store', default=None,</code>
7. <code>                    help='Choose browser: chrome or firefox')</code>
8. <code> </code>
9. <code> </code>
10. <code>@pytest.fixture(scope='function')</code>
11. <strong><code>def browser(request):</code></strong>
12. <code>   browser_name = request.config.getoption('browser_name')</code>
13. <code>   browser = None</code>
14. <code>   <strong>if</strong> browser_name == 'chrome':</code>
15. <code>       <strong>print</strong>('<strong>\n</strong>start chrome browser')</code>
16. <code>       browser = webdriver.Chrome()</code>
17. <code>   <strong>elif</strong> browser_name == 'firefox':</code>
18. <code>       <strong>print</strong>('<strong>\n</strong>start firefox browser')</code>
19. <code>       browser = webdriver.Firefox()</code>
20. <code>   <strong>else</strong>:</code>
21. <code>       <strong>raise</strong> pytest.UsageError('--browser_name should be chrome or firefox')</code>
22. <code>   <strong>yield</strong> browser</code>
23. <code>   <strong>print</strong>('<strong>\n</strong>quit browser')</code>
24. <code>   browser.quit()</code>
25. <code> </code>

Запустите следующий тест без параметра командой “pytest -s -v test_parser.py”:

1. **<code>from selenium.webdriver.common.by import By</code></strong>
2. <code> </code>
3. <code>link = 'http://selenium1py.pythonanywhere.com/'</code>
4. <code> </code>
5. <code> </code>
6. <strong><code>def test_guest_should_see_login_link(browser):</code></strong>
7. <code>   browser.get(link)</code>
8. <code>   browser.find_element(By.CSS_SELECTOR, '#login_link')</code>
9. <code> </code>

Вы получите ошибку “ERROR _pytest.config.exceptions.UsageError: --browser_name should be chrome or firefox”.

Чтобы не вводить параметр браузера можно использовать значение по умолчанию. Для этого необходимо добавить
“default='chrome'” в “conftest.py”.

Запустите тест в браузере Chrome: “pytest -s -v --browser_name=chrome test_parser.py” и в Firefox: “pytest -s -v
--browser_name=firefox test_parser.py”.

<h4>7.5.5 Плагины и перезапуск тестов</h4>

Pytest имеет богатый выбор плагинов для расширений возможностей фреймворка. Полный список доступных фреймворков можно
найти в документации[^51].

Обсудим еще одну распространенную проблему, часто возникающую при написании сквозных тестов в Selenium, — flaky-тесты
или “мигающие” автотесты. Это тесты, которые иногда проваливаются из-за внешних факторов, не зависящих от нас, или из-за
трудно воспроизводимых ошибок, хотя в большинстве случаев они успешно проходят. Это может произойти во время тестов
из-за одновременных обновлений сайта, проблем с сетью или странных совпадений. Несмотря на то, что устранение таких
проблем и выявление причин ошибок необходимо, в реальном мире это часто требует значительных усилий. Таким образом,
чтобы убедиться, что тест действительно обнаружил ошибку и не произошел случайный сбой, мы можем повторить неудачный
тест.

Реализация этого — простой процесс. Мы будем использовать плагин pytest-rerunfailures.

Нам понадобится установить плагин в виртуальную среду и, соответственно, добавить плагин в наши зависимости в файл
“requirements.txt”. Установить плагин можно командой “pip install pytest-rerunfailures”.

Чтобы установить количество повторных запусков неудачных тестов, вы можете добавить параметр командной строки: “--reruns
n”, где “n” представляет количество повторных запусков. Если тесты пройдены на любом из повторных запусков, тестовый
запуск будет считаться успешным, а количество повторных запусков будет отображаться в отчёте для дальнейшего анализа
проблемных тестов.

Дополнительно используем параметр “--tb=line”, чтобы сократить вывод лога: “pytest -v --tb=line --reruns 1
--browser_name=chrome test_rerun.py”.

Давайте запустим два теста, один из которых будет выполняться успешно, а второй будет падать с ошибкой, и посмотрим как
выполняется перезапуск тестов:

1. **<code>from selenium.webdriver.common.by import By</code></strong>
2. <code> </code>
3. <code>link = 'https://demoqa.com/'</code>
4. <code> </code>
5. <code> </code>
6. <strong><code>def test_guest_should_see_elements_card_on_the_main_page(browser):</code></strong>
7. <code>   browser.get(link)</code>
8. <code>   browser.find_element(By.XPATH, '//*[@class="card mt-4 top-card"][.//h5[text()="Elements"]]')</code>
9. <code> </code>
10. <code> </code>
11. <strong><code>def test_guest_should_see_join_now_button_on_the_main_page(browser):</code></strong>
12. <code>   browser.get(link)</code>
13. <code>   browser.find_element(By.CSS_SELECTOR, '#join_now')</code>
14. <code> </code>

Вы увидите отчет о запуске тестов: "1 failed, 1 passed, 1 rerun in 50.16s", следовательно первоначально провалившийся
тест был перезапущен.

<h2>Глава 8. Использование Page Object Model</h2>

<h3>8.1 Что такое Page Object?</h3>

В этой мы будем использовать принципы объектно-ориентированного программирования и вам не помешает освежить в памяти
основные принципы ООП[^52].

<h4>8.1.1 Code Style</h4>

В сообществе программистов существует широко распространенное соглашение, известное как “стиль кода” (Code Style). Стиль
кода охватывает все аспекты, не связанные с функциональностью самого кода, такие как форматирование, имена переменных и
функций, и другие подобные соображения. Python, в частности, хвалят за его удобочитаемость, но даже этот язык может
превратиться в нечитаемый беспорядок, если его не поддерживать должным образом. Нечитаемый код представляет опасность,
поскольку становится трудным для понимания и может вызвать путаницу в будущем как у вас, так и у ваших коллег. С другой
стороны, хорошо написанный код предлагает множество преимуществ, включая экономию времени при исправлении ошибок, более
плавную адаптацию новых членов команды и более эффективную разработку кода в целом. Поэтому поддержание читаемости кода
всегда должно быть одним из приоритетов.

Вам обязательно стоит прочитать рекомендации по написанию кода[^53] и сопроводительной документации[^54] для языка
Python. В предыдущих частях мы кратко обсуждали эту тему, а теперь более уместно углубиться в неё более подробно и
рассмотрим некоторые важные аспекты.

<h5>8.1.1.1 Отступы</h5>

Отступы являются важным аспектом синтаксиса Python, поскольку они означают вложенность блоков, таких как тело условного
оператора или цикла. Важно отметить, что на следующих шагах должны поддерживаться правильные отступы для всех функций
внутри класса.

1. <code><em># Тест вне класса, отступ не нужен.</em></code>
2. <strong><code>def test_equal(a, b):</code></strong>
3. <code>   <strong>assert</strong> a == b, f'Expected {a=} to be equal {b=}'</code>
4. <code> </code>
5. <code> </code>
6. <strong><code>class TestInteractionsPage:</code></strong>
7. <code>   """Class represents Interactions tab.</code>
8. <code>   Sortable</code>
9. <code>   Selectable,</code>
10. <code>   Resizable,</code>
11. <code>   Droppable</code>
12. <code>   """</code>
13. <code> </code>
14. <code>   <em># Класс внутри класса. Необходим отступ, чтобы показать вложенность.</em></code>
15. <code>   <strong>class</strong> TestSortablePage:</code>
16. <code>       """Class represents Sortable tab tests."""</code>
17. <code>       sortable_page_link = 'https://demoqa.com/sortable'</code>
18. <code> </code>
19. <code>       <em># Тест внутри вложенного класса. Необходим отступ.</em></code>
20. <code>       <strong>def</strong> test_order_of_list_can_be_changed(self, driver):</code>
21. <code>           """Test order of list can be changed."""</code>
22. <code>           sortable_page = SortablePage(driver, self.sortable_page_link)</code>
23. <code>           sortable_page.open()</code>
24. <code>           order_of_list_before = sortable_page.get_items_of_list()</code>
25. <code>           sortable_page.change_list_order()</code>
26. <code>           order_of_list_after = sortable_page.get_items_of_list()</code>
27. <code>           <strong>assert</strong> order_of_list_before != order_of_list_after, \</code>
28. <code>           'Expected order of list to be different.' \</code>
29. <code>           f'Order before: {order_of_list_before}' \</code>
30. <code>           f'Order after: {order_of_list_after}'</code>
31. <code> </code>

<h5>8.1.1.2 Имена переменных и финкций</h5>

Именование — важнейший элемент написания читаемого кода. Будь то объявление переменных, определение функций или
присвоение имен классам, важно убедиться, что назначенные имена имеют смысл и точно отражают суть соответствующих
объектов. Избегайте использования однобуквенных или расплывчатых имен, таких как “var1”, “x”, “y”, “my_function”,
“class2” и т. д.

Цель состоит в том, чтобы создать код, который говорит сам за себя и не требует дополнительных объяснений. Если вы
обнаружите, что хотите написать поясняющий комментарий, это хорошая возможность реорганизовать код и устранить
необходимость в комментариях за счет улучшения соглашений об именах.

Как правило, компании имеют свои внутренние соглашения относительно именования переменных. Однако общие отраслевые
правила именования переменных относительно одинаковы в разных организациях.

Функции и методы пишутся с помощью “snake_case”:

1. **<code>def test_revertable_draggable_will_return_to_current_position_after_dragging(self, driver):</code></strong>
2. <code>   <strong>pass</strong></code>
3. <code> </code>
1. <strong><code>def switch_to_frame(self, frame_locator, timeout=5):</code></strong>
2. <code>   <strong>pass</strong></code>
3. <code> </code>

Классы пишут с помощью “CamelCase”:

1. **<code>class AccordianPage(BasePage):</code></strong>
2. <code>   <strong>pass</strong></code>
3. <code> </code>
1. <strong><code>class TestAccordianPage:</code></strong>
2. <code>   <strong>pass</strong></code>
3. <code> </code>

Константы пишут в стиле “UPPERCASE”:

1. `NO_ERRORS_TEXT = 'No errors'`
2. ` `

<h5>8.1.1.3 Максимальная простота кода</h5>

Распространенные принципы DRY[^55] (Don’t repeat yourself) и KISS[^56] (Keep it simple, stupid).

Рассмотрим основные моменты хороших практик и принципов программирования:

* Старайтесь писать как можно более простой код, избегая ненужной сложности.
* Сведите к минимуму использование сложных конструкций, таких как лямбда-выражения, карты и другие сложные методы, если
  только они не являются действительно необходимыми.
* Всякий раз, когда у вас есть возможность заменить часть кода более простой альтернативой, сделайте это.
* Подчеркните линейную структуру кода, так как ее легче понять и следовать.
* Избегайте чрезмерной вложенности блоков кода, так как это может затруднить чтение кода.
* По возможности избегайте дублирования логики. Если вы заметили повторяющиеся шаблоны, выделите эту логику в отдельный
  компонент или функцию, чтобы избежать повторения.
* По возможности предпочтите явный код неявному коду. Лучше иметь четкий и понятный код, чем полагаться на скрытое или
  магическое поведение.

<h4>8.1.2 Code Style в автотестах</h4>

Важные принципы написания автотестов:

* Стремитесь поддерживать высокий уровень линейности в своем тестовом коде, сводя к минимуму использование ветвлений и
  циклов в тестовых примерах. Если вы обнаружите, что вам нужно ввести условные операторы (например, оператор “if”) в
  свои тесты, рассмотрите возможность разделения теста на два отдельных теста или внесите изменение тестовой среды,
  чтобы исключить необходимость ветвления.
    * Уменьшая число ветвлений и сохраняя линейность тестового кода, вы можете улучшить читаемость и удобство
      сопровождения ваших тестов, упрощая их понимание и устранение неполадок.
* Сведите к минимуму использование зависимых тестов, основанных на определенном порядке выполнения. По мере расширения
  набора тестов вы можете захотеть запускать тесты одновременно в нескольких потоках, что усложняется при использовании
  зависимых тестов. Кроме того, зависимые тесты могут привести к проблемам с надежностью.
    * Избегая зависимостей между тестами, вы обеспечиваете большее распараллеливание и повысите общую надежность набора
      тестов. Каждый тест должен быть автономным и независимым, что обеспечивает гибкость выполнения и более точные
      результаты тестирования. Подробнее о зависимостях в тестах вы можете прочитать в статье “...почему зависимости
      между тестами это плохо?”[^57].


* Стремитесь сделать ваши тесты самодостаточными и независимыми от конкретного контента. Вместо этого сосредоточьтесь на
  подготовке необходимых данных в самом тесте и обеспечьте надлежащую очистку после завершения теста. Рекомендуется
  использовать чистые браузеры и создавать новые учетные записи пользователей для повышения воспроизводимости.
    * Генерируя необходимые данные и управляя тестовой средой в тестовом коде, вы уменьшаете зависимость от внешних
      факторов, делая ваши тесты более надежными и воспроизводимыми при различных исполнениях. Такой подход обеспечивает
      лучшую изоляцию и повышает общую стабильность тестового набора.
* Названия тестов должны соответствовать единому стилю и эффективно отражать различия между похожими сценариями. Подобно
  добавлению имен к тест-кейсам в тестовой документации, вы можете использовать аналогичные подходы для именования своих
  тестов.
    * Важно выбрать описательные и осмысленные имена для ваших тестов, подчеркивая конкретные различия или тестируемые
      аспекты. Следуя единому стилю именования, вы повышаете удобочитаемость и понятность своего набора тестов. Кроме
      того, понятные и информативные названия тестов облегчают эффективную коммуникацию и сотрудничество между членами
      команды.
* Вместо того, чтобы дублировать идентичные тесты с небольшими различиями в содержании, например, в языке интерфейса,
  рекомендуется их параметризовать. Параметризация позволяет повторно использовать одну и ту же тестовую логику,
  предоставляя разные входные значения.
    * Параметризируя тесты, вы можете определить один тестовый пример и указать различное содержимое в качестве
      параметров. Такой подход устраняет дублирование кода, повышает удобство сопровождения и упрощает процесс
      добавления новых тест-кейсов с аналогичными характеристиками.
* Рекомендуется писать тесты, которые являются атомарными и неделимыми, то есть каждый тест фокусируется на определенной
  функциональности или сценарии. Вместо того, чтобы создавать один большой тест, который проверяет сразу несколько
  аспектов, лучше разбить его на более мелкие, более целенаправленные тесты. Такой подход позволяет лучше локализовать
  проблему и упрощает устранение неполадок при их возникновении.
    * Сохраняя тесты атомарными, вы можете точно определить местонахождение сбоев и определить конкретную
      функциональность, вызывающую проблему. Это также способствует модульности и возможности повторного использования,
      поскольку тесты меньшего размера можно комбинировать или повторно использовать в разных сценариях.

Рекомендую ознакомится с практиками написания “хорошего” кода в статьях “Что такое красивый код, и как его писать?”[^58]
и “Практика хорошего кода”[^59].

<h4>8.1.3 Подготовка окружения</h4>

Целью этого дипломного проекта является обучение основам автоматизированного тестирования UI и, чтобы приблизиться к
достижению этой цели, вы должны практиковаться.

Мы создадим отдельный публичный репозиторий и будем постепенно добавлять и изменять код автотестов, чтобы сохранить
историю коммитов и приблизиться к промышленной разработке.

Начнём:

1. Создайте отдельный публичный репозиторий с осмысленным названием на GitHub.
2. Добавьте в свой репозиторий файлы “README.md” и Python “.gitignore”.
3. Клонируйте его к себе на локальную машину.
4. Добавьте туда файл “conftest.py” из предыдущего модуля. Убедитесь дополнительно, что там есть параметр для задания
   языка интерфейса, по умолчанию равный “en”. Вам придется реализовать выбор локализации самостоятельно. Знаний,
   полученных в предыдущих модулях вполне достаточно.
5. Убедитесь что ни во вложенных папках, ни во внешних папках нет других файлов “conftest.py”.
6. Добавьте в репозиторий файл “requirements.txt”, добавьте туда зависимости и установите их в новое виртуальное
   окружение для проекта.
7. Создайте пустой файл “__init__.py”, чтобы работали относительные импорты.
8. Создайте файл “test_main_page.py” и добавьте в него тест:
1. **<code>def test_guest_can_go_to_login_page(browser):</code></strong>
2. <code>   link = 'http://selenium1py.pythonanywhere.com/'</code>
3. <code>   browser.get(link)</code>
4. <code>   login_link = browser.find_element(By.CSS_SELECTOR, '#login_link')</code>
5. <code>   login_link.click()</code>
6. <code> </code>
9. Убедитесь, что тест работает, с помощью следующей команды: “pytest -v --tb=line --language=en test_main_page.py”.
10. Добавьте в “README.md” небольшое описание тестового проекта.
11. Зафиксируйте изменения коммитом с осмысленным сообщением.

<h4>8.1.4 Что такое Page Object Model?</h4>

Page Object Model (Page Object) — это широко используемый шаблон программирования в автоматизации тестирования, особенно
для тестирования веб-продуктов. Он служит стандартным подходом и предлагает удобный способ структурирования кода,
облегчая его обслуживание, модификацию и удобство использования.

Фундаментальная концепция модели Page Object Model заключается в представлении каждой веб-страницы приложения в виде
объекта класса. Взаимодействие со страницей можно описать с помощью методов внутри класса. В идеале тесты, использующие
Page Objects, должны быть сосредоточены на бизнес-логике тестового сценария, абстрагируясь от методов Selenium для
взаимодействия браузера и страницы. Такой подход упрощает обслуживание, поскольку изменения макета страницы не потребуют
модификации связанных тестов. Вместо этого необходимо обновить только класс, представляющий страницу.

К объектной модели страницы применяются те же принципы разработки кода: улучшение читаемости кода и инкапсуляция деталей
в абстрактные методы. Тесты должны быть написаны просто и понятно, с выделением повторяющихся сегментов кода в отдельные
функции. Внутри Page Object мы отличаем логику действий, таких как аутентификация пользователя, от конкретных деталей
реализации (например, поиск поля электронной почты, ввод данных, поиск поля пароля, ввод данных, расположение кнопки и
т. д.).

Рассмотрим такой простой тест-кейс:

1. открыть главную страницу;

2. Перейти на страницу логина.

Ожидаемый результат: открыта страница логина.

Давайте посмотрим на кода теста, который реализует первую часть этого теста “test_main_page.py”:

1. `link = 'http://selenium1py.pythonanywhere.com/'`
2. ` `
3. ` `
4. **<code>def test_guest_can_go_to_login_page(browser):</code></strong>
5. <code>   browser.get(link)</code>
6. <code>   login_link = browser.find_element(By.CSS_SELECTOR, '#login_link')</code>
7. <code>   login_link.click()</code>
8. <code> </code>

Что здесь происходит?

Открывается ссылка, находится элемент с определенным селектором и производится клик на этот элемент.

Что мы на самом деле имеем в виду?

Мы хотим открыть страницу логина. Давайте выделим это действие в отдельную функцию с понятным названием, пока все в том
же файле “test_main_page.py”:

1. **<code>def go_to_login_page(browser):</code></strong>
2. <code>   login_link = browser.find_element(By.CSS_SELECTOR, '#login_link')</code>
3. <code>   login_link.click()</code>
4. <code> </code>

И наш тест упрощается:

1. **<code>def test_guest_can_go_to_login_page(browser):</code></strong>
2. <code>   browser.get(link)</code>
3. <code>   go_to_login_page(browser)</code>
4. <code> </code>

При написании последующих тестов, требующих перехода на страницу входа с главной страницы, нет необходимости дублировать
или переписывать код. Вместо этого мы можем повторно использовать ранее написанный метод, гарантируя возможность
повторного использования кода и уменьшая избыточность.

<h4>8.1.5 Почему именно Page Object?</h4>

Хотя можно хранить всю тестовую логику в одном файле, таком как «steps.py», этот подход может стать проблематичным по
мере увеличения размера веб-продукта и сложности его состояний и переходов. Файл может стать слишком большим, что
затруднит поиск определенных методов. Кроме того, бывают случаи, когда один и тот же метод может иметь разные реализации
на разных страницах. Например, в нашем интернет-магазине функция “добавить в корзину” доступна как со страницы каталога,
так и со страницы отдельного продукта.

Чтобы улучшить организацию и удобство сопровождения, полезно сгруппировать методы, которые логически связаны с
конкретной веб-страницей, в выделенный класс в нашем коде. Эта концепция приводит к термину Page Object, который
относится к абстрактному объекту, инкапсулирующему методы для взаимодействия с конкретной веб-страницей.

Важно! Обычно методы у Page Object бывают двух типов: сделать что-то и проверить что-то.

Рассмотрим страницу товара[^60] в интернет магазине.

Какие могут быть методы у Page Object, ассоциированного с такой страницей?

Запишем основные сценарии:

* добавить в корзину;
* проверить, что есть сообщение об успешном добавлении в корзину;
* перейти к написанию отзыва;
* проверить, что есть название, цена, описание товара;
* вернуться на главную.

Стоит отметить, что все утверждения также реализованы в виде отдельных методов. В самом тестовом примере нет
вспомогательных ключевых слов, таких как “assert”, а скорее описательное представление шагов, аналогичное нашей тестовой
документации.

Тесты будут выглядеть примерно так:

1. **<code>def test_add_to_cart(browser):</code></strong>
2. <code>   product_page = ProductPage(browser, url='')  <em># инициализируем объект Page Object</em></code>
3. <code>   product_page.open()  <em># открываем страницу в браузере</em></code>
4. <code>   product_page.should_be_add_to_cart_button()  <em># проверяем что есть кнопка добавления в корзину</em></code>
5. <code>   product_page.add_product_to_cart()  <em># жмем кнопку добавить в корзину</em></code>
6. <code>   product_page.should_be_success_message()  <em># проверяем что есть сообщение с нужным текстом</em></code>
7. <code> </code>

<h2>Литература</h2>

Куликов, С. С. Тестирование программного обеспечения. Базовый курс. (3-е издание) / С. С. Куликов. – Newtown,
Pennsylvania : EPAM Systems, 2023. – 301 с. –
URL: [https://svyatoslav.biz/software_testing_book/](https://svyatoslav.biz/software_testing_book/) (дата обращения:
20.03.2023). – Режим доступа: свободный

Тестирование программного обеспечения // Wikipedia : сайт. –
URL: [https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения](https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения) (
дата обращения: 20.03.2023)

ISTQB Glossary : сайт. –
URL: [https://glossary.istqb.org/en_US/term/testing-4-2](https://glossary.istqb.org/en_US/term/testing-4-2) (дата
обращения: 20.03.2023)

Фундаментальная теория тестирования // Habr : сайт. –
URL: [https://habr.com/ru/articles/549054/](https://habr.com/ru/articles/549054/) (дата обращения: 20.03.2023)

Принципы тестирования: нас 7 // Habr : сайт. –
URL: [https://habr.com/ru/articles/699990/](https://habr.com/ru/articles/699990/) (дата обращения: 20.03.2023)

Основы HTML // MDN Web Docs : сайт. – URL: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/) (дата
обращения: 20.03.2023)

Основы CSS // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics](https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics) (
дата обращения: 21.03.2023

LearnGitBranching : сайт. –
URL: [https://learngitbranching.js.org/?locale=ru_RU](https://learngitbranching.js.org/?locale=ru_RU) (дата обращения:
28.03.2023)

Markdown-Cheatsheet // GitHub : сайт. –
URL: [https://github.com/Lexxx42/Markdown-Cheatsheet](https://github.com/Lexxx42/Markdown-Cheatsheet) (дата обращения:
29.03.2023)

Markdown Cheatsheet // GitHub : сайт. –
URL: [https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) (
дата обращения: 29.03.2023)

Download PyCharm: Python IDE for Professional Developers by JetBrains : сайт. –
URL: [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/) (дата обращения:
05.04.2023)

Download Python | Python.org : сайт. – URL: [https://www.python.org/downloads/](https://www.python.org/downloads/) (дата
обращения: 05.04.2023)

Statcounter Global Stats - Browser, OS, Search Engine including Mobile Usage Share : сайт. –
URL: [https://gs.statcounter.com/](https://gs.statcounter.com/) (дата обращения: 05.04.2023)

ChromeDriver - WebDriver for Chrome : сайт. –
URL: [https://chromedriver.chromium.org/](https://chromedriver.chromium.org/) (дата обращения: 05.04.2023)

Скачать chromedriver для автоматизации Google Chrome в Python : сайт. –
URL: [https://selenium-python.com/install-chromedriver-chrome](https://selenium-python.com/install-chromedriver-chrome) (
дата обращения: 05.04.2023)

DEMOQA : сайт. – URL: [https://demoqa.com/](https://demoqa.com/) (дата обращения: 05.04.2023)

Selenium Test Pages : сайт. –
URL: [https://testpages.herokuapp.com/styled/index.html](https://testpages.herokuapp.com/styled/index.html) (дата
обращения: 18.05.2023)

Инструменты разработчика // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools](https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools) (
дата обращения: 18.05.2023)

XPath // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/en-US/docs/Web/XPath](https://developer.mozilla.org/en-US/docs/Web/XPath) (дата
обращения: 06.04.2023)

HTML Attribute Reference // W3Schools Online Web Tutorials : сайт. –
URL: [https://www.w3schools.com/tags/ref_attributes.asp](https://www.w3schools.com/tags/ref_attributes.asp) (дата
обращения: 11.04.2023)

selenium.webdriver.support.expected_conditions // Selenium : сайт. –
URL: [https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html) (
дата обращения: 21.04.2023)

Conventions for Python test discovery // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery](https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery) (
дата обращения: 26.04.2023)

Test fixture // Wikipedia : сайт. –
URL: [https://en.wikipedia.org/wiki/Test_fixture#Software](https://en.wikipedia.org/wiki/Test_fixture#Software) (дата
обращения: 28.04.2023)

How to implement xunit-style set-up // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/how-to/xunit_setup.html](https://docs.pytest.org/en/latest/how-to/xunit_setup.html) (
дата обращения: 28.04.2023)

PEP 20 – The Zen of Python // peps.python.org : сайт. –
URL: [https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/) (дата обращения: 28.04.2023)

Adding finalizers directly // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly](https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly) (
дата обращения: 28.04.2023)

How to use skip and xfail to deal with tests that cannot succeed // pytest.org : сайт. –
URL: [https://pytest.org/en/stable/how-to/skipping.html](https://pytest.org/en/stable/how-to/skipping.html) (дата
обращения: 03.05.2023)

Override a fixture on a folder (conftest) level // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?highlight=fixture%20folder#override-a-fixture-on-a-folder-conftest-level](https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?highlight=fixture%20folder#override-a-fixture-on-a-folder-conftest-level) (
дата обращения: 04.05.2023)

Oscar - Sandbox : сайт. – URL: [http://selenium1py.pythonanywhere.com/](http://selenium1py.pythonanywhere.com/) (дата
обращения: 04.05.2023)

How to parametrize fixtures and test functions // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/how-to/parametrize.html](https://docs.pytest.org/en/latest/how-to/parametrize.html) (
дата обращения: 04.05.2023)

Mozilla : сайт. – URL: [https://www.mozilla.org/en-US/firefox/new/](https://www.mozilla.org/en-US/firefox/new/) (дата
обращения: 04.05.2023)

GitHub : сайт. –
URL: [https://github.com/mozilla/geckodriver/releases](https://github.com/mozilla/geckodriver/releases) (дата обращения:
04.05.2023)

Установка драйвера geckodriver для Firefox Selenium // selenium-python : сайт. –
URL: [https://selenium-python.com/install-geckodriver](https://selenium-python.com/install-geckodriver) (дата обращения:
04.05.2023)

How to change command line options defaults // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption](https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption) (
дата обращения: 04.05.2023)

Plugin List // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/reference/plugin_list.html](https://docs.pytest.org/en/latest/reference/plugin_list.html) (
дата обращения: 04.05.2023)

Шпаргалка по принципам ООП // Tproger : сайт. –
URL: [https://tproger.ru/translations/oop-principles-cheatsheet/](https://tproger.ru/translations/oop-principles-cheatsheet/) (
дата обращения: 11.05.2023)

PEP 8 – Style Guide for Python Code // peps.python.org : сайт. –
URL: [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/) (дата обращения: 11.05.2023)

PEP 257 – Docstring Conventions // peps.python.org : сайт. –
URL: [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/) (дата обращения: 11.05.2023)

Don't repeat yourself // Wikipedia : сайт. –
URL: [https://en.wikipedia.org/wiki/Don't_repeat_yourself](https://en.wikipedia.org/wiki/Don't_repeat_yourself) (дата
обращения: 11.05.2023)

KISS principle // Wikipedia : сайт. –
URL: [https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle) (дата обращения:
11.05.2023)

...почему зависимости между тестами это плохо? // barancev.github.io : сайт. –
URL: [http://barancev.github.io/test-deps-are-evil/](http://barancev.github.io/test-deps-are-evil/) (дата обращения:
11.05.2023)

Что такое красивый код, и как его писать? // Habr : сайт. –
URL: [https://habr.com/ru/articles/266969/](https://habr.com/ru/articles/266969/) (дата обращения: 11.05.2023)

Практика хорошего кода // Habr : сайт. –
URL: [https://habr.com/ru/articles/206868/](https://habr.com/ru/articles/206868/) (дата обращения: 11.05.2023)


<!-- Footnotes themselves at the bottom. -->

## Notes

[^1]:
Тестирование программного обеспечения // Wikipedia : сайт. –
URL: [https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения](https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения) (
дата обращения: 20.03.2023)

[^2]:
Куликов, С. С. Тестирование программного обеспечения. Базовый курс. (3-е издание) / С. С. Куликов. – Newtown,
Pennsylvania : EPAM Systems, 2023. – 301 с. – URL: https://svyatoslav.biz/software_testing_book/ (дата обращения:
20.03.2023). – Режим доступа: свободный

[^3]:
ISTQB Glossary : сайт. –
URL: [https://glossary.istqb.org/en_US/term/testing-4-2](https://glossary.istqb.org/en_US/term/testing-4-2) (дата
обращения: 20.03.2023)

[^4]:
Фундаментальная теория тестирования // Habr : сайт. –
URL: [https://habr.com/ru/articles/549054/](https://habr.com/ru/articles/549054/) (дата обращения: 20.03.2023)

[^5]:
Принципы тестирования: нас 7 // Habr : сайт. –
URL: [https://habr.com/ru/articles/699990/](https://habr.com/ru/articles/699990/) (дата обращения: 20.03.2023)

[^6]:

     Основы HTML // MDN Web Docs : сайт. – URL: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/) (дата обращения: 20.03.2023)

[^7]:
Основы CSS // MDN Web Docs : сайт. –
URL: https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics (дата обращения: 21.03.2023)

[^8]:
LearnGitBranching : сайт. –
URL: [https://learngitbranching.js.org/?locale=ru_RU](https://learngitbranching.js.org/?locale=ru_RU) (дата обращения:
28.03.2023)

[^9]:
Markdown-Cheatsheet // GitHub : сайт. –
URL: [https://github.com/Lexxx42/Markdown-Cheatsheet](https://github.com/Lexxx42/Markdown-Cheatsheet) (дата обращения:
29.03.2023)

[^10]:
Markdown Cheatsheet // GitHub : сайт. –
URL: [https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) (
дата обращения: 29.03.2023)

[^11]:
Download PyCharm: Python IDE for Professional Developers by JetBrains : сайт. –
URL: [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/) (дата обращения:
05.04.2023)

[^12]:
Download Python | Python.org : сайт. – URL: [https://www.python.org/downloads/](https://www.python.org/downloads/) (дата
обращения: 05.04.2023)

[^13]:
Statcounter Global Stats - Browser, OS, Search Engine including Mobile Usage Share : сайт. –
URL: [https://gs.statcounter.com/](https://gs.statcounter.com/) (дата обращения: 05.04.2023)

[^14]:
ChromeDriver - WebDriver for Chrome : сайт. –
URL: [https://chromedriver.chromium.org/](https://chromedriver.chromium.org/) (дата обращения: 05.04.2023)

[^15]:
Скачать chromedriver для автоматизации Google Chrome в Python : сайт. –
URL: [https://selenium-python.com/install-chromedriver-chrome](https://selenium-python.com/install-chromedriver-chrome) (
дата обращения: 05.04.2023)

[^16]:
DEMOQA : сайт. – URL: [https://demoqa.com/](https://demoqa.com/) (дата обращения: 05.04.2023)

[^17]:
Selenium Test Pages : сайт. –
URL: [https://testpages.herokuapp.com/styled/index.html](https://testpages.herokuapp.com/styled/index.html) (дата
обращения: 18.05.2023)

[^18]:
Basic Web Page Title : сайт. –
URL: [https://testpages.herokuapp.com/styled/basic-web-page-test.html](https://testpages.herokuapp.com/styled/basic-web-page-test.html) (
дата обращения: 18.05.2023)

[^19]:
Инструменты разработчика // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools](https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools) (
дата обращения: 18.05.2023)

[^20]:
Basic Web Page Title : сайт. –
URL: [https://testpages.herokuapp.com/styled/basic-web-page-test.html](https://testpages.herokuapp.com/styled/basic-web-page-test.html) (
дата обращения: 18.05.2023)

[^21]:
Test Page For Element Attributes : сайт. –
URL: [https://testpages.herokuapp.com/styled/attributes-test.html](https://testpages.herokuapp.com/styled/attributes-test.html) (
дата обращения: 18.05.2023)

[^22]:
Windows Example Test : сайт. – URL: https://testpages.herokuapp.com/styled/windows-test.html (дата обращения:
18.05.2023)

[^23]:
Welcome to the Find By Playground : сайт. –
URL: [https://testpages.herokuapp.com/styled/find-by-playground-test.html](https://testpages.herokuapp.com/styled/find-by-playground-test.html) (
дата обращения: 18.05.2023)

[^24]:
HTML5 Form Elements Test Page : сайт. –
URL: [https://testpages.herokuapp.com/styled/html5-form-test.html](https://testpages.herokuapp.com/styled/html5-form-test.html) (
дата обращения: 18.05.2023)

[^25]:
XPath // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/en-US/docs/Web/XPath](https://developer.mozilla.org/en-US/docs/Web/XPath) (дата
обращения: 06.04.2023)

[^26]:
DEMOQA Practice Form : сайт. –
URL: [https://demoqa.com/automation-practice-form](https://demoqa.com/automation-practice-form) (дата обращения:
18.05.2023)

[^27]:
DEMOQA Text Box : сайт. – URL: [https://demoqa.com/text-box](https://demoqa.com/text-box) (дата обращения: 18.05.2023)

[^28]:
DEMOQA Links : сайт. – URL: [https://demoqa.com/links](https://demoqa.com/links) (дата обращения: 18.05.2023)

[^29]:
DEMOQA Practice Form : сайт. –
URL: [https://demoqa.com/automation-practice-form](https://demoqa.com/automation-practice-form) (дата обращения:
18.05.2023)

[^30]:
HTML Attribute Reference // W3Schools Online Web Tutorials : сайт. –
URL: [https://www.w3schools.com/tags/ref_attributes.asp](https://www.w3schools.com/tags/ref_attributes.asp) (дата
обращения: 11.04.2023)

[^31]:
DEMOQA Links : сайт. – URL: [https://demoqa.com/links](https://demoqa.com/links) (дата обращения: 18.05.2023)

[^32]:
DEMOQA Text Box : сайт. – URL: [https://demoqa.com/text-box](https://demoqa.com/text-box) (дата обращения: 18.05.2023)

[^33]:
DEMOQA Select Menu : сайт. – URL: [https://demoqa.com/select-menu](https://demoqa.com/select-menu) (дата обращения:
19.05.2023)

[^34]:
DEMOQA Practice Form : сайт. –
URL: [https://demoqa.com/automation-practice-form](https://demoqa.com/automation-practice-form) (дата обращения:
18.05.2023)

[^35]:
DEMOQA Alerts : сайт. – URL: [https://demoqa.com/alerts](https://demoqa.com/alerts) (дата обращения: 19.05.2023)

[^36]:
DEMOQA Dynamic Properties : сайт. –
URL: [https://demoqa.com/dynamic-properties](https://demoqa.com/dynamic-properties) (дата обращения: 20.05.2023)

[^37]:
selenium.webdriver.support.expected_conditions // Selenium : сайт. –
URL: [https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html) (
дата обращения: 21.04.2023)

[^38]:
Conventions for Python test discovery // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery](https://docs.pytest.org/en/stable/explanation/goodpractices.html#conventions-for-python-test-discovery) (
дата обращения: 26.04.2023)

[^39]:
Test fixture // Wikipedia : сайт. –
URL: [https://en.wikipedia.org/wiki/Test_fixture#Software](https://en.wikipedia.org/wiki/Test_fixture#Software) (дата
обращения: 28.04.2023)

[^40]:
How to implement xunit-style set-up // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/how-to/xunit_setup.html](https://docs.pytest.org/en/latest/how-to/xunit_setup.html) (
дата обращения: 28.04.2023)

[^41]:
PEP 20 – The Zen of Python // peps.python.org : сайт. –
URL: [https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/) (дата обращения: 28.04.2023)

[^42]:
Adding finalizers directly // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly](https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly) (
дата обращения: 28.04.2023)

[^43]:
How to use skip and xfail to deal with tests that cannot succeed // pytest.org : сайт. –
URL: [https://pytest.org/en/stable/how-to/skipping.html](https://pytest.org/en/stable/how-to/skipping.html) (дата
обращения: 03.05.2023)

[^44]:
Override a fixture on a folder (conftest) level // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?highlight=fixture%20folder#override-a-fixture-on-a-folder-conftest-level](https://docs.pytest.org/en/7.1.x/how-to/fixtures.html?highlight=fixture%20folder#override-a-fixture-on-a-folder-conftest-level) (
дата обращения: 04.05.2023)

[^45]:
Oscar - Sandbox : сайт. – URL: [http://selenium1py.pythonanywhere.com/](http://selenium1py.pythonanywhere.com/) (дата
обращения: 04.05.2023)

[^46]:
How to parametrize fixtures and test functions // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/how-to/parametrize.html](https://docs.pytest.org/en/latest/how-to/parametrize.html) (
дата обращения: 04.05.2023)

[^47]:
Mozilla : сайт. – URL: [https://www.mozilla.org/en-US/firefox/new/](https://www.mozilla.org/en-US/firefox/new/) (дата
обращения: 04.05.2023)

[^48]:
GitHub : сайт. –
URL: [https://github.com/mozilla/geckodriver/releases](https://github.com/mozilla/geckodriver/releases) (дата обращения:
04.05.2023)

[^49]:
Установка драйвера geckodriver для Firefox Selenium // selenium-python : сайт. –
URL: [https://selenium-python.com/install-geckodriver](https://selenium-python.com/install-geckodriver) (дата обращения:
04.05.2023)

[^50]:
How to change command line options defaults // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption](https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption) (
дата обращения: 04.05.2023)

[^51]:
Plugin List // docs.pytest.org : сайт. –
URL: [https://docs.pytest.org/en/latest/reference/plugin_list.html](https://docs.pytest.org/en/latest/reference/plugin_list.html) (
дата обращения: 04.05.2023)

[^52]:
Шпаргалка по принципам ООП // Tproger : сайт. –
URL: [https://tproger.ru/translations/oop-principles-cheatsheet/](https://tproger.ru/translations/oop-principles-cheatsheet/) (
дата обращения: 11.05.2023)

[^53]:
PEP 8 – Style Guide for Python Code // peps.python.org : сайт. –
URL: [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/) (дата обращения: 11.05.2023)

[^54]:
PEP 257 – Docstring Conventions // peps.python.org : сайт. –
URL: [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/) (дата обращения: 11.05.2023)

[^55]:
Don't repeat yourself // Wikipedia : сайт. –
URL: [https://en.wikipedia.org/wiki/Don't_repeat_yourself](https://en.wikipedia.org/wiki/Don't_repeat_yourself) (дата
обращения: 11.05.2023)

[^56]:
KISS principle // Wikipedia : сайт. –
URL: [https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle) (дата обращения:
11.05.2023)

[^57]:

     ...почему зависимости между тестами это плохо? // barancev.github.io : сайт. – URL: [http://barancev.github.io/test-deps-are-evil/](http://barancev.github.io/test-deps-are-evil/) (дата обращения: 11.05.2023)

[^58]:
Что такое красивый код, и как его писать? // Habr : сайт. –
URL: [https://habr.com/ru/articles/266969/](https://habr.com/ru/articles/266969/) (дата обращения: 11.05.2023)

[^59]:
Практика хорошего кода // Habr : сайт. –
URL: [https://habr.com/ru/articles/206868/](https://habr.com/ru/articles/206868/) (дата обращения: 11.05.2023)

[^60]:
Oscar - Sandbox: The shellcoder's handbook : сайт. –
URL: [http://selenium1py.pythonanywhere.com/en-gb/catalogue/the-shellcoders-handbook_209/](http://selenium1py.pythonanywhere.com/en-gb/catalogue/the-shellcoders-handbook_209/) (
дата обращения: 11.05.2023)
