<!-----

You have some errors, warnings, or alerts. If you are using reckless mode, turn it off to see inline alerts.
* ERRORs: 0
* WARNINGs: 0
* ALERTS: 14

Conversion time: 7.651 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β34
* Sat May 20 2023 07:17:08 GMT-0700 (PDT)
* Source doc: Автоматизация тестирования UI с помощью Selenium и Pytest
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 0; ALERTS: 14.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>


Geekbrains

Факультет тестирования ПО

<h2>Автоматизация тестирования UI с использованием Selenium и Pytest</h2>

**Дипломный проект**

студента 1 года обучения

специальности “Тестирование ПО”

Конюхов А.С.

Руководитель

Шафигуллин И.К.

Радужный

2023

**Дипломный проект “Автоматизация тестирования UI с использованием Selenium и Pytest”**

**Содержание**

[TOC]

<h2>Введение</h2>


<p>Актуальность

Автоматизация проникает во все сферы деятельности человека, избавляет от рутин и тестирование ПО не исключение.
Автоматизация позволяет разгрузить тестировщика от рутинных проверок во время ретеста и регрессивного тестирования. А
также для повышения качества разрабатываемого продукта путем встраивания в цикл непрерывной интеграции и непрерывной
доставки. Актуальность темы дипломной работы связана со значительным распространением автоматизации тестирования и языка
программирования Python и заключается в необходимости разработки рекомендаций по изучению данного направления для
начинающих и практикующих специалистов по обеспечению качества.

<p>Цели и задачи

Цель дипломной работы является разработка дорожной карты развития начинающего специалиста по обеспечению качества
разработки ПО. Познакомить с инструментами и сформировать компетенции для успешного развития в направлении автоматизации
тестирования на языке программирования Python.

Задачами дипломной работы в связи с указанной целью являются:

* изучить основные понятия теории тестирования;
* исследовать наиболее распространенные web-технологии;
* изучить систему контроля версий Git;
* изучить базовые возможности языка программирования Python;
* изучить основные возможности и методы Selenium;
* исследовать расширение возможностей тестирования с помощью фреймворков;
* раскрыть необходимость использования паттерна Page Object Model;
* изучить различные методы формирования отчетов о тестировании.

<p>Объект и предмет исследования

Объектом дипломной работы является изучение начинающим специалистом автоматизации на языке Python для тестирования
пользовательского интерфейса сайтов, и способы ускорения профессионального развития в данном направлении.

Предметом дипломной работы являются открытые источники в сети интернет, книги и курсы посвященные тестированию ПО.

<p>Научная и практическая значимость

Научная новизна заключается в нахождении нового подхода к обучению специалистов в направлении автоматизации на языке
программирования Python.

Практическая значимость заключается в снижении времени, необходимого для получения навыков, необходимых для
использования в автоматизации тестирования UI web-приложений.

<p>Инструменты и технологии

В дипломном проекте будут использованы следующие инструменты: DevTools, PyCharm, Python, Selenium WebDriver, Pytest,
Allure.

Будут использованы следующие технологии: ChromeDriver, geckodriver, pytest-html, pytest-rerunfailures, allure-pytest,
Page Object Model.

<p>Рекомендации по изучению

Дипломный проект представляет из себя курс по освоению (или расширению уже имеющихся) знаний в области автоматизации
тестирования на языке программирования Python.

Рекомендуется проходить курс последовательно и самостоятельно изучать дополнительные материалы. Ссылки на некоторые
материалы будут приведены по ходу курса, но рекомендуется проводить самостоятельную работу по поиску актуальной
информации.

<h2>Глава 1. Теория тестирования</h2>

<h3>1.1 Что такое тестирование?</h3>

<h4>1.1.1 Определение тестирования ПО</h4>

Чтобы погрузиться в автоматизацию тестирования необходимо разобраться с тем что такое тестирование, для чего оно
необходимо и как оно осуществляется.

Есть несколько разных трактовок о том, чем же является тестирование ПО, рассмотрим некоторые из них и вычленим общие
черты тестирования.

Тестирование программного обеспечения - процесс исследования, испытания программного продукта, имеющий своей целью
проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных
определенным образом.[^1]

Святослав Куликов дает такое определение тестирования ПО в своей книге «Тестирование программного обеспечения. Базовый
курс.»:

Тестирование программного обеспечения — процесс анализа программного средства и сопутствующей документации с целью
выявления дефектов и повышения качества продукта.[^2]

Международный совет по тестированию программного обеспечения (ISTQB, International Software Testing Qualifications
Board) содержит только определение тестирования:

The process consisting of all lifecycle activities, both static and dynamic, concerned with planning, preparation and
evaluation of a component or system and related work products to determine that they satisfy specified requirements, to
demonstrate that they are fit for purpose and to detect defects.[^3]

Итак мы узнали, что тестирование - это поиск дефектов (багов) с целью повышения качества продукта. Как же эти баги
обнаруживают?

1. Используем источники ожидаемого поведения системы (тестовые оракулы) для понимания как должна работать система.

2. Производим манипуляции с системой, чтобы она проявила свое истинное поведение.

3. Сравниваем ожидаемый результат с фактическим.

<h4>1.1.2 Кто такой тестировщик?</h4>

Тестировщик - специалист заботящийся о качестве системы в виде обнаружения дефектов до того, как их обнаружат
пользователи системы.

Тестирование служит для повышения качества системы через обнаружение дефектов и их устранение.

Вы наверное слышали такие термины как Tester, QC, QA. Их довольно часто путают между собой или смешивают, поэтому
давайте разберемся в терминологии.

* Тестирование — это уже непосредственно процесс проверки результатов работы на соответствие установленным требованиям.
* QC — Контроль качества продукта — анализ результатов тестирования и качества новых версий выпускаемого продукта.
* QA — Обеспечение качества продукта — изучение возможностей по изменению и улучшению процесса разработки, улучшению
  коммуникаций в команде, где тестирование является только одним из аспектов обеспечения качества.

Без понимания основ теории тестирования невозможно стать хорошим автоматизатором тестирования. Она необходима для
понимания важности работы тестировщика и его участии в развитии продукта и работе в команде.

Заострим внимание ещё на одном важном аспекте теории тестирования - принципах тестирования.

Выделяют семь принципов тестирования:

1. Исчерпывающее тестирование невозможно (Exhaustive testing is impossible).
2. Тестирование демонстрирует наличие дефектов, а не их отсутствие (Testing shows presence of defects).
3. Тестирование зависит от контекста (Testing is context depending).
4. Раннее тестирование (Early testing).
5. Скопление или кластеризация дефектов (Defects clustering).
6. Парадокс пестицида (Pesticide paradox).
7. Заблуждение об отсутствии ошибок (Absence-of-errors fallacy).

Подробнее о принципах тестирования вы можете ознакомиться в статьях на Habr “Фундаментальная теория тестирования[^4]” и
“Принципы тестирования: нас 7[^5]”.

<h3>1.2 Классификация тестирования</h3>

Существует много различных классификаций тестирования и каждый автор обладает своим мнением по классификации
тестирования. Поэтому говоря о классификации тестирования лучше уточнить согласно какому источнику от вас хотят услышать
ответ.

Проанализировав различные источники можно разделить классификацию тестирования по различным способам классифицировать
само тестирование.

По уровням тестирования: модульное, интеграционное, системное, End-to-End, приёмочное.

По принципу работы с приложением: позитивное, негативное.

По доступности: черный ящик, серый ящик, белый ящик.

По запуску кода: статическое, динамическое.

По степени автоматизации: ручное, полуавтоматизированное, автоматизированное.

По зависимости от целей тестирования: функциональное, нефункциональное.

В свою очередь каждая классификация содержит в себе входящие в себя подкатегории, которые на стыке друг с другом
образуют новые виды тестирования. Например, на пересечении конфигурационного и UI тестирования возникает тестирование
совместимости, направленное на проверку того, что интерфейс корректно работает при различных конфигурациях ПО и
платформ. А на срезе тестирования UI и безопасности возникает тестирование локализации и интернационализации.

<h3>1.3. Тестирование UI</h3>

Важно понимать на каких аспектах работы ПО сосредоточено UI тестирование для успешного изучения автоматизации UI
тестирования.

UI тестирование, также известное как тестирование пользовательского интерфейса, представляет собой тип тестирования
программного обеспечения, которое фокусируется на графическом пользовательском интерфейсе приложения. Тестирование UI
проводится, чтобы удостовериться, что интерфейс приложения работает должным образом, а также что им легко пользоваться и
ориентироваться.

Тестирование пользовательского интерфейса важно для выявления проблем, таких как неработающие ссылки, неправильное
форматирование или некорректное поведение при взаимодействии с интерфейсом, работу элементов взаимодействия с
пользователем таких как кнопки, поля ввода, модальные окна, выпадающие списки, меню и прочее.

Несколько примеров UI тестирования:

1. Функциональное тестирование. Этот тип тестирования гарантирует, что компоненты пользовательского интерфейса, такие
   как кнопки и формы, работают должным образом. Например, если пользователь нажимает кнопку, UI должен выполнить
   ожидаемое действие.

2. Юзабилити-тестирование. Этот тип тестирования гарантирует, что пользовательский интерфейс прост в использовании и
   навигации. Например, проверяется подходящий размер шрифта и визуально привлекательная цветовая схема.

3. Тестирование производительности. Этот тип тестирования гарантирует, что пользовательский интерфейс отзывчив и хорошо
   работает в различных условиях. Например, проверяется насколько быстро загружается интерфейс и как он работает при
   одновременном доступе к нему нескольких пользователей.

4. Тестирование совместимости. Этот тип тестирования гарантирует, что пользовательский интерфейс хорошо работает на
   различных устройствах и платформах. Например, проверяется правильность отображения приложения на экранах разных
   размеров и разрешений, работу приложения в разных браузерах.

5. Тестирование доступности. Этот тип тестирования гарантирует, что пользовательский интерфейс доступен для
   пользователей с ограниченными возможностями. Например, он проверяет, можно ли использовать приложение с программой
   чтения с экрана и что используемые цвета доступны пользователям с цветовой слепотой.

Это всего лишь несколько примеров типов тестирования пользовательского интерфейса, которые можно выполнить, чтобы
убедиться, что пользовательский интерфейс приложения работает должным образом.

Наибольшее распространение получило именно автоматизированное функциональное тестирование пользовательского интерфейса,
которое мы и будем изучать на стеке Selenium + Pytest.

Подведём небольшой итог этой главы: без знания основ тестирования невозможно стать хорошим автоматизатором тестирования.
Требуется гораздо более глубокое понимание того как, когда и зачем производится определённый вид тестирования. Только в
сочетании знания теории тестирования и навыков программирования возможно добиться высоких показателей качества продукта,
который вы разрабатываете.

<h2>Глава 2. Базовые знания web-технологий</h2>

<h3>2.1 Основы HTML</h3>

<h4>2.1.1 Что такое HTML?</h4>

HTML — это не язык программирования, а язык разметки, используемый для структурирования и представления веб-страниц и их
содержимого. Он позволяет организовывать текст в абзацы, создавать маркированные списки, вставлять изображения и
отображать данные в таблицах. Понимание основ HTML и его особенностей имеет важное значение для любого тестировщика. Но
для автоматизации тестирования является неотъемлемой часть знаний.

HTML использует теги, которые представляют собой метки, используемые для разметки и классификации информации, что
упрощает для браузеров интерпретацию и форматирование контента на веб-сайте. Проще говоря, теги служат ключевыми
словами, которые указывают браузеру, как обрабатывать и отображать содержимое сайта.

<h4>2.1.2 HTML элемент</h4>

Давайте рассмотрим структуру HTML элемента.



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")

Рисунок 1. HTML элемент.

Главными частями нашего элемента являются:

1. Открывающий тег (Opening tag): Состоит из имени элемента (в данном случае, "p"), заключённого в открывающие и
   закрывающие угловые скобки. Открывающий тег указывает, где элемент начинается или начинает действовать, в данном
   случае — где начинается абзац.
2. Закрывающий тег (Closing tag): Это то же самое, что и открывающий тег, за исключением того, что он включает в себя
   косую черту перед именем элемента. Закрывающий элемент указывает, где элемент заканчивается, в данном случае — где
   заканчивается абзац. Отсутствие закрывающего тега является одной из наиболее распространённых ошибок начинающих и
   может приводить к странным результатам.
3. Контент (Content): Это контент элемента, который в данном случае является просто текстом.
4. Элемент(Element): Открывающий тег, закрывающий тег и контент вместе составляют элемент.[^6]
   Элементы могут иметь различные атрибуты, например класс:

<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")

Рисунок 2. Атрибут элемента.

Атрибуты предоставляют дополнительную информацию об элементе, которая не предназначена для отображения как часть самого
содержимого. В этом примере “class” — это имя атрибута, а “editor-note” — это значение атрибута. Атрибут “class”
позволяет присвоить элементу описательное имя, которое впоследствии можно использовать для ссылки на элемент в целях
стилизации или других функций.

Атрибуты часто используются для поиска элементов на странице, поэтому необходимо обратить на них внимание при изучении
HTML.

<h3>2.2 Основы CSS</h3>

<h4>2.2.1 Так что же такое CSS?</h4>

CSS (Cascading Style Sheets) — это код, используемый для настройки внешнего вида вашей веб-страницы. Понимание основ CSS
позволяет управлять такими аспектами, как цвет текста, расположение контента на экране и добавление фоновых изображений
и цветов. Для автоматизации тестирования необходимо знать как меняются свойства отображения элемента, такие как цвет,
размер и активное состояние.

Подобно HTML, CSS считается не языком программирования, а скорее языком таблиц стилей. Его цель — выборочное применение
стилей к определенным элементам в документах HTML.

<h4>2.2.2 Анатомия набора правил CSS</h4>

Давайте посмотрим на CSS более подробно:



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.png "image_tooltip")

Рисунок 3. Набор правил CSS.

Вся структура называется набором правил (но зачастую для краткости "правило"). Отметим также имена отдельных частей:

Селектор (Selector)

Имя HTML-элемента в начале набора правил. Он выбирает элемент(ы) для применения стиля (в данном случае, элементы p ).
Для стилизации другого элемента, просто измените селектор.

Объявление (Declaration)

Единственное правило, например color: red; указывает, какие из свойств элемента вы хотите стилизовать.

Свойства (Properties)

Способы, которыми вы можете стилизовать определённый HTML-элемент (в данном случае, color является свойством для
элементов [<p>](https://developer.mozilla.org/ru/docs/Web/HTML/Element/p)). В CSS вы выбираете, какие свойства вы хотите
затронуть в вашем правиле.

Значение свойства (Property value)

Справа от свойства, после двоеточия, у нас есть значение свойства, которое выбирает одно из множества возможных
признаков для данного свойства (существует множество значений color, помимо red).[^7]

<h3>2.3 Основы JavaScript</h3>

JavaScript — это язык программирования, который повышает интерактивность вашего веб-сайта. Он включает различные
функции, такие как интерактивные игры, отклики на нажатие кнопок или ввод данных в формы, динамический стиль и анимацию.

Вы можете ознакомиться с синтаксисом языка самостоятельно. Здесь же мы поговорим о наиболее часто встречаемых элементах
взаимодействиях: alert, confirm и prompt.

Alert - функция, которая показывает сообщение и ждёт, пока пользователь нажмёт кнопку “ОК”.

Например:

“alert("Привет");”



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.png "image_tooltip")

Рисунок 4. Alert JS.

Окно, появляющееся поверх элементов интерфейса, называется модальным. Пользователь не сможет взаимодействовать с
интерфейсом, пока не закроет модальное окно. В случае alert это нажатие на кнопку “OK”.

Код “let test = prompt("Test");“ отобразит модальное окно с полем ввода текста и кнопки “OK”, “Cancel”.



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image5.png "image_tooltip")

Рисунок 5. Prompt JS.

Функция confirm отображает окно с текстом вопроса и двумя кнопками: “OK”, “Cancel”. Результат - истина, если
пользователь выбрал “OK” и ложь в противном случае.

Например:

“let right = confirm("Ты всегда прав?");“



<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image6.png "image_tooltip")

Рисунок 6. Confirm JS.

В автоматизации тестирования Java Script часто используется как для тестирования UI, так и для тестирования баз данных и
API. Для автоматизации тестирования на Python вам понадобится базовое знание синтаксиса, так как некоторые вещи, чтобы
сэкономить время и не писать самостоятельно, мы используем из уже реализованных методов браузера. А они в свою очередь
реализованы на языке Java Script.

Подводя итог под знакомством с web-технологиями, которые сейчас активно используются для взаимодействия приложений с
пользователями, нужно отметить, что знание основ этих технологий позволяет эффективно производить тестирование
пользовательского интерфейса.

<h2>Глава 3. Знакомство с системой контроля версий Git</h2>

<h3>3.1 Что такое система контроля версий?</h3>

Система контроля версий — это программное обеспечение, которое позволяет хранить историю изменений в любом документе или
файле. Таким образом, вы можете легко просматривать и откатывать изменения, сделанные каким-либо участником проекта. Это
очень полезно, когда необходимо восстановить старую версию документа или сравнить две разные версии файла. Кроме того,
она позволяет отслеживать, кто и что изменил в документе или файле и помогает избежать конфликтов при одновременном
редактировании одного и того же файла.

Система контроля версий Git является распределенной, она используется для отслеживания изменений в файлах и директориях
проекта. Позволяет разработчикам контролировать и отслеживать изменения в проекте.

Чтобы работать с Git, необходимо инициализировать репозиторий в папке с проектом. После этого можно добавлять изменения
в репозиторий, создавая различные версии проекта. Можно также просматривать историю изменений и откатываться к любой
предыдущей версии. Также можно объединять работы различных разработчиков в один проект.

Я рекомендую начать изучение Git в игровой форме на сайте LearnGitBranching[^8], которое позволит вам изучить все
основные возможности и команды.

Большинство современных сред разработки поддерживают интуитивно понятный интерфейс для работы с системой контроля версий
Git и вам не надо знать наизусть все команды.

<h3>3.2. Файл README.md и разметка Markdown</h3>

Большинство open source проектов размещаются в GitHub и я рекомендую поступать также. Это не только даёт вам возможность
поделиться кодом с коллегами, но и работать совместно над проектом со специалистами из разных стран.

Стоит заострить внимание на аспекте README.md файла, который создаётся для каждого репозитория. Некоторые разработчики
пренебрегают созданием этого файла потому что не осознают до конца всей важности его наличия и влияния на сообщество.

README.md — это файл в репозитории GitHub, который служит файлом документации для репозитория. Он написан в формате
Markdown и предоставляет информацию о назначении репозитория, инструкции по установке, примеры использования и любую
другую информацию касательно содержимого проекта, например, примеры оформления баг-репортов или способы связаться с
автором для совместной разработки.

Файл README.md важен, потому что он помогает пользователям понять назначение и использование репозитория. Он также
предоставляет важную информацию, которая может помочь пользователям быстро и легко начать работу с репозиторием. Кроме
того, наличие хорошо написанного файла README.md может помочь привлечь участников в репозиторий и улучшить совместную
работу.

Часто вам потребуется читать и составлять подобные файлы, а также поддерживать их в актуальном состоянии. Поэтому важно
понимать, что должен содержать такой файл.

* Название: название вашего проекта или репозитория.
* Описание: краткое описание того, что делает ваш проект или репозиторий.
* Оглавление: список разделов в вашем файле README.md, если файл получился объёмным.
* Установка: инструкции по установке и настройке вашего проекта или репозитория.
* Использование: инструкции по использованию вашего проекта или репозитория.
* Участие: рекомендации о том, как внести свой вклад в ваш проект или репозиторий (опционально).
* Лицензия: информация о лицензии вашего проекта или репозитория.

Вы можете использовать синтаксис Markdown для форматирования контента и добавления заголовков, списков, изображений,
ссылок и других элементов.

Я перевел на русский язык удобную и информативную инструкцию по применению разметки Markdown[^9] с оригинальной Markdown
Cheatsheet by Adam Pritchard[^10] специально для тех, кому комфортнее читать актуальную документацию на родном языке.
Обязательно советую ознакомиться с ней или другими источниками.

Отметим, что автоматизация тестирования тесно связана с разработкой, поскольку является продуктом в продукте (ваш
тестовый фреймворк можно считать полноценным приложением). Поэтому без уверенного знания системы контроля версий
работать практически невозможно. А без надлежащего оформления сопутствующей документации проекта вы уже через месяц
забудете какие команды нужно использовать, чтобы получить необходимые результаты. Кроме того, отсутствие актуальной
документации не только приведёт к трате времени на объяснение того как работает ваш проект, но и в целом ухудшает
потенциальное качество проекта.

<h2>Глава 4. Основы Python</h2>

<h3>4.1 Знакомство с языком программирования Python</h3>

Программирование - это, по сути, процесс предоставления компьютеру инструкций для выполнения конкретной задачи. Для
этого нам нужно использовать язык программирования, который, по сути, представляет собой способ общения с компьютером
таким образом, чтобы он мог его понять.

Python - популярный язык программирования, известный своей простотой в изучении и использовании. Некоторые из основных
концепций программирования, применимых к Python, включают:

1. Синтаксис. Синтаксис языка программирования относится к правилам и соглашениям по написанию кода на этом языке. В
   Python, например, мы используем отступы для обозначения блоков кода, и мы используем определенные ключевые слова,
   такие как “if”, “else” и “while”, чтобы управлять потоком программы.
2. Типы и структуры данных. В Python мы можем работать с различными типами данных, включая числа, строки и списки. Мы
   также можем использовать структуры данных, такие как словари и множества, для организации данных и управления ими.
3. Структуры управления и ветвления. Структуры управления используются для управления потоком программы. В Python мы
   можем использовать операторы “if” для выполнения определенного кода, только если выполняется определенное условие,
   циклы “while” для повторения блока кода, пока определенное условие выполняется, и циклы “for” для повторения
   последовательности элементов.
4. Функции. Функции — это повторно используемые блоки кода, которые выполняют определенную задачу. В Python мы можем
   определить наши собственные функции с помощью ключевого слова “def”, а также можем использовать встроенные функции,
   такие как “print” и “len”.
5. Объектно-ориентированное программирование. Объектно-ориентированное программирование — это парадигма
   программирования, в которой особое внимание уделяется использованию объектов для представления данных и поведения. В
   Python мы можем определять наши собственные классы и объекты, которые позволяют нам организовывать наш код и
   создавать более сложные программы.

Это всего лишь несколько основных концепций программирования, применимых к Python.

Базовый синтаксис языка программирования Python достаточно прост и рекомендуется самостоятельно его изучить.

<h3>4.2 Базовые принципы ООП</h3>

Важным элементом для автоматизатора тестирования на любом языке программирования является понимание
объектно-ориентированной парадигмы, которая сейчас очень распространена в промышленной разработке.

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов,
которые могут содержать данные (атрибуты) и функции (методы), работающие с этими данными. ООП — это мощная парадигма
программирования, которую можно использовать для создания более модульного, повторно используемого и поддерживаемого
кода.

Однако количество кода растёт по экспоненте с количеством классов, которые вы внедряете по мере разработки.

Существует четыре основных принципа ООП:

1. Инкапсуляция. Относится к практике сокрытия внутренних деталей объекта от внешнего мира и раскрытия только
   общедоступного интерфейса, который можно использовать для взаимодействия с объектом. Это помогает защитить
   целостность объекта и упрощает поддержку и изменение кода с течением времени.
2. Абстракция. Относится к практике представления сложных систем или понятий с использованием более простых и общих
   понятий. Абстракция позволяет нам сосредоточиться на основных характеристиках объекта и игнорировать детали, которые
   не имеют отношения к нашей текущей задаче.
3. Наследование. Относится к практике создания новых классов, которые наследуют атрибуты и методы существующих классов.
   Наследование позволяет нам повторно использовать код и создавать более специализированные классы, основанные на
   функциональности более общих классов.
4. Полиморфизм. Относится к практике использования одного интерфейса для представления нескольких типов объектов.
   Полиморфизм позволяет нам писать более общий код, который может работать с широким спектром объектов, без
   необходимости знать конкретные детали каждого объекта.

В Python мы можем использовать принципы ООП для создания классов и объектов, которые инкапсулируют данные и
функциональность. Мы можем определить классы, используя ключевое слово “class”, а затем создать экземпляры этих классов,
используя имя класса, за которым следуют круглые скобки. Например:

1. **<code><em>class Person:</em></code></strong>
2. <code><em>   <strong>def</strong> __init__(self, name, age):</em></code>
3. <code><em>       self.name = name</em></code>
4. <code><em>       self.age = age</em></code>
5. <code><em> </em></code>
6. <code><em>   <strong>def</strong> say_hello(self):</em></code>
7. <code><em>       <strong>print</strong>(f'Hello, my name is {self.name} and I am {self.age} years old.')</em></code>
8. <code><em> </em></code>
9. <code><em> </em></code>
10. <code><em>person1 = Person('John', 30)</em></code>
11. <code><em>person2 = Person('Jane', 25)</em></code>
12. <code><em> </em></code>
13. <code><em>person1.say_hello()  # prints "Hello, my name is John and I am 30 years old."</em></code>
14. <code><em>person2.say_hello()  # prints "Hello, my name is Jane and I am 25 years old."</em></code>
15. <code><em> </em></code>

В этом примере мы определяем класс “Person”, который имеет два атрибута (“name” и “age”) и один метод (“say_hello()”).
Затем мы создаем два экземпляра класса “Person” (“person1” и “person2”) и вызываем метод “say_hello()” для каждого
экземпляра.

В целом, принципы ООП являются важным инструментом для создания более модульного, повторно используемого и
поддерживаемого кода в Python. Освоив использование ООП, вы сможете поднять свои навыки программирования на новый
уровень и создавать более мощные, гибкие и эффективные программы. К тому же, ООП повсеместно используется в
автоматизации тестирования и наибольшее распространение получила Page Model Object, о которой мы поговорим позже.

<h2>Глава 5. Знакомство с Selenium</h2>

<h3>5.1 Что такое Selenium?</h3>

Selenium — это среда тестирования программного обеспечения с открытым исходным кодом, которая используется для
автоматизации веб-приложений. Она предоставляет набор инструментов и API, которые позволяют QA-инженерам
автоматизировать тестирование и решать задачи, такие как взаимодействие с пользователем, ввод данных и проверка вывода.
Selenium поддерживает различные языки программирования, такие как Java, Python, C#, Ruby, JavaScript и другие.

Selenium работает, имитируя действия пользователя в веб-браузере. Он использует компонент драйвера, который
взаимодействует с веб-браузером и позволяет тестам автоматизации взаимодействовать с веб-страницей. Драйвер Selenium
WebDriver является наиболее часто используемым драйвером и поддерживает популярные браузеры, такие как Chrome, Firefox,

Safari и Edge.

Вот несколько способов использования Selenium для автоматизированного тестирования.

Функциональное тестирование: Selenium можно использовать для автоматизации функциональных тестов, чтобы убедиться, что
веб-приложения работают должным образом. Это включает в себя проверку того, что элементы пользовательского интерфейса
отображаются правильно, что ссылки и кнопки работают должным образом, а поля формы принимают допустимый ввод.

Регрессионное тестирование: Selenium можно использовать для автоматизации регрессионных тестов, чтобы гарантировать, что
изменения, внесённые в веб-приложение, не привели к появлению новых ошибок или проблем. Регрессионные тесты можно
запускать несколько раз, чтобы убедиться, что приложение продолжает функционировать должным образом после каждого
внесения изменений. Тут стоит отметить тот факт, что именно регрессионное тестирование является первым кандидатом на
автоматизацию.

Интеграционное тестирование: Selenium можно использовать для автоматизации интеграционных тестов, чтобы убедиться, что
различные части веб-приложения работают вместе правильно. Это включает в себя тестирование взаимодействия между
интерфейсными и внутренними компонентами веб-приложения. Стоит упомянуть, что большинство авторов относят автоматизацию
тестирования UI к End-to-end тестам, так как они проходят через всё приложение начиная от ввода в пользовательский
интерфейс и заканчивая выводом конечных данных в нём же.

Кросс-браузерное тестирование: Selenium можно использовать для автоматизации кросс-браузерного тестирования, чтобы
убедиться, что веб-приложения работают согласованно в разных браузерах и версиях. Это помогает выявлять и устранять
проблемы, связанные с браузерами.

В целом, Selenium — это мощный инструмент для автоматизации тестирования веб-приложений, который может помочь
QA-инженерам сэкономить время и силы за счёт автоматизации повторяющихся и трудоёмких задач тестирования.

<h3>5.2 Настройка первого запуска браузера с помощью Selenium Webdriver</h3>

На этом этапе я рекомендую создать свой учебный репозиторий в GitHub и повторять и анализировать действия в среде
разработке PyCharm[^11]. Создайте свой проект, настройте виртуальное окружение и не забудьте про README.md файл.
Рекомендую добавить README.md и .gitignore для Python сразу при создании репозитория в GitHub.

Мы будем с вами изучать автоматизацию на языке Python, поэтому первое, что вы должны сделать - это скачать версию
3.11.2[^12] (на момент написания - это последняя версия языка Python).

В виртуальном окружении устанавливаем библиотеку Selenium: “pip install selenium==4.*”.

В этом дипломном проекте мы будем работать с драйвером для Chrome, так как на данный момент это самый популярный браузер
согласно ресурсу statcounter[^13], и в первую очередь следует убедиться, что веб-приложение работает для большинства
пользователей.



<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image7.png "image_tooltip")

Рисунок 7. Статистика использования браузеров.

Драйвер для Chrome разрабатывается командой браузера и носит название ChromeDriver. Скачать нужную версию можно с
официального сайта.[^14]

Подробности установки драйвера хорошо описаны на сайте selenium-python.com[^15].

Далее мы создадим скрипт, который открывает веб-страницу и заполняет форму. Я буду использовать сайты demoqa.com[^16] и
testpages.herokuapp.com[^17] для демонстрации возможностей Selenium.

Рекомендую попробовать запускать команды по отдельности или пользоваться отладчиком среды разработки, чтобы получить
более глубокое понимание работы программы.

1. **<code>import time</code></strong>
2. <code> </code>
3. <code><em># webdriver - это набор команд для управления браузером.</em></code>
4. <strong><code>from selenium import webdriver</code></strong>
5. <code> </code>
6. <code><em># By - класс, который позволяет выбрать способ поиска элемента.</em></code>
7. <strong><code>from selenium.webdriver.common.by import By</code></strong>
8. <code> </code>
9. <code><em># Инициализация браузера Chrome.</em></code>
10. <code>driver = webdriver.Chrome()</code>
11. <code> </code>
12. <code><em># Задержка в 5 секунд, чтобы вы увидили, что происходит в браузере.</em></code>
13. <code><em># Попробуйте её закомментировать и посмотреть, что из этого выйдет.</em></code>
14. <code>time.sleep(5)</code>
15. <code> </code>
16. <code><em># Метод get открывает страницу в браузере.</em></code>
17. <code>driver.get('https://testpages.herokuapp.com/styled/basic-html-form-test.html')</code>
18. <code>time.sleep(5)</code>
19. <code> </code>
20. <code><em># Метод find_element() позволяет найти нужный элемент на сайте по указанному локатору (
    селектору).</em></code>
21. <code><em># Метод принимает в качестве аргументов способ поиска элемента и значение, по которому будет
    осуществляться поиск.</em></code>
22. <code><em># Ищем поле ввода.</em></code>
23. <code>username_field = driver.find_element(By.CSS_SELECTOR, '[name="username"]')</code>
24. <code> </code>
25. <code><em># Вводим текст в поле, используя метод send_keys().</em></code>
26. <code>username_field.send_keys('Alexander')</code>
27. <code>time.sleep(5)</code>
28. <code> </code>
29. <code><em># Найдем кнопку, которая отправляет введённый текст.</em></code>
30. <code>submit_button = driver.find_element(By.CSS_SELECTOR, '[value="submit"]')</code>
31. <code> </code>
32. <code><em># Скажем драйверу, что нужно кликнуть по кнопке.</em></code>
33. <code><em># После этой команды мы должны увидеть ввёденные значения в форму.</em></code>
34. <code>submit_button.click()</code>
35. <code>time.sleep(5)</code>
36. <code> </code>
37. <code><em># Мы должны не забыть закрыть окно браузера, но если этого не сделать, то за нас это сделает сборщик
    мусора Python.</em></code>
38. <code>driver.quit()</code>
39. <code> </code>

Пронаблюдайте за работой скрипта, а затем еще раз пробегитесь по коду глазами. Одна из особенностей языка Python в том,
что он пишется почти как предложения на английском языке. Такая высокая читаемость кода позволяет гораздо легче изучать
язык.

Следует обязательно добавить к проекту файл “requirements.txt”. В этот файл следует занести все зависимости, которые
используются для работы вашей программы, чтобы любой мог склонировать себе ваш репозиторий и запустить его на своей
локальной машине.

Записать такой файл можно вручную или воспользоваться командой: “pip freeze > requirements.txt”.

<h3>5.3 Поиск элементов</h3>

Тема поиска элементов критично важна для автоматизации тестирования UI и мы остановимся на ней подробнее.

<h4>5.3.1 Поиск элементов с помощью CSS-селекторов</h4>

Ниже приведены части элементов HTML-страницы, по которым можно найти элемент:

* id;
* значение атрибута;
* name;
* class;
* tag.

Использование тега для поиска элемента используется в сочетание с другими частями элемент, потому что важно выбрать
единственный объект для взаимодействия кроме некоторый исключений из этого правила. И, как правило, на странице
присутствует несколько элементов с одинаковым тегом, а когда таких элементов нет все равно не рекомендуется использовать
исключительно тег элемента, так как страница может измениться: могут быть добавлены новые элементы, изменено наполнение
страницы.

Давайте откроем страницу Basic Web Page Title[^18] и попробуем найти элемент первого параграфа.

Чтобы это сделать вам потребуется использовать DevTools вашего браузера.

Инструменты разработчика (от англ. "development tools" или сокращённо "DevTools") - это программы, которые позволяют
создавать, тестировать и отлаживать (debug) программное обеспечение.[^19]

Я рекомендую вам использовать Google Chrome.

Для включения DevTools можно нажать F12 на клавиатуре.

Ниже приведён кусок html-кода страницы:

1. <code><<strong>div</strong> class="centered"></code>
2. <code>   <<strong>p</strong> id="para1" class="main">A paragraph of text</<strong>p</strong>></code>
3. <code>   <<strong>p</strong> id="para2" class="sub">Another paragraph of text</<strong>p</strong>></code>
4. <code></<strong>div</strong>></code>

<h5>5.3.1.1 Поиск по id</h5>

У элемента с первым параграфом есть атрибут id=”para1”, а значит, мы однозначно можем найти его с помощью селектора
“#para1” (символ “#” означает, что мы ищем по “id” со значением “para1”).

Нужно всегда проверять правильность подобранного локатора в консоли разработчика. Откройте консоль разработчика и
перейдите в ней в таб “Elements”. Затем нажмите “ctrl+F” и в открывшейся внизу поисковой строке введите “#para1”. Если
селектор написан правильно,

то вы увидите подсвеченный элемент на веб-странице, а также элемент будет подсвечен жёлтым цветом в html-коде. Еще в
поисковой строке вы увидите количество найденных элементов.



<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image8.png "image_tooltip")

Рисунок 8. Поиск по id.

<h5>5.3.1.2 Поиск по class</h5>

Рассмотрим поиск второго параграфа по классу. Поскольку классы используются повсеместно для задания стилей элементов, то
у них есть краткая форма поиска: “.sub”. Необходимо указать на использование класса для поиска использовав точку, а
затем ввести значение класса.



<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image9.png "image_tooltip")

Рисунок 9. Поиск по class.

Важно отметить, что поиск по классу чувствителен к регистру и поиск “.Sub” уже не найдёт нужный элемент.

<h5>5.3.1.3 Поиск по tag</h5>

Чтобы найти элемент по тегу, просто напишите название тега в поисковой строке. Поиск по тегам не очень удобен, т.к.
разработчики используют небольшое количество тегов для разметки страниц, и скорее всего, одному тегу будет
соответствовать несколько элементов. Но есть некоторые теги, которые почти наверняка будут присутствовать в единичном
экземпляре: html, title, h1.

Давайте попробуем найти заголовок нашей страницы Basic Web Page Title[^20].



<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image10.png "image_tooltip")

Рисунок 10. Поиск по tag.

<h5>5.3.1.4 Поиск по значению атрибута</h5>

Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по “id” в следующем
виде “[id="para1"]” вместо “#para1” и поиск по “class” в следующем виде “[class="sub"]” вместо “.sub”.

Вариант с квадратными скобками принято использовать для тех видов поиска, у которых отсутствует короткая поисковая
команда.

Рассмотрим пример параграфа с атрибутами (This paragraph has attributes) и попробуем найти содержащий его элемент на
странице Test Page For Element Attributes[^21].



<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image11.png "image_tooltip")

Рисунок 11. Поиск по значению атрибута.

Поиск по “name” является разновидностью поиска по значению атрибута и выделяется отдельно в Selenium WebDriver.

<h5>5.3.1.5 Поиск элементов с помощью составных CSS-селекторов</h5>

Допустим мы не можем найти необходимый нам элемент на странице используя простой селектор, так как он находит сразу
несколько элементов сразу. Что делать в такой ситуации?

Вот тут нам и понадобится умение комбинировать селекторы и иерархическая структура страницы.

<h6>5.3.1.5.1 Использование порядкового номера дочернего элемента</h6>

Например, нам необходимо получить только текст пункта “The Attributes window, has no name.” на странице Windows Example
Test[^22].



<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image12.png "image_tooltip")

Рисунок 12. Поиск с использованием порядкового номера дочернего элемента.

Псевдокласс “:nth-child(3)” позволяет выбрать третий дочерний элемент тега “ul” с тегом “li”.

<h6>5.3.1.5.2 Использование дочерних элементов</h6>

Допустим нам нужно содержимое параграфа “This is a paragraph text” на странице Welcome to the Find By Playground[^23],
заключённое в тег “a”. Для этого можно использовать следующую команду для поиска элемента: “.specialDiv > p.normal #a1”.

Символ “>” означает, что нужно взять элемент строго на один уровень вложенности ниже элемента с классом specialDiv. Этот
элемент должен иметь тег “p” и класс “normal”, а уже далее от этого элемента производится поиск по “id”.



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image13.png "image_tooltip")

Рисунок 13. Поиск с использованием дочернего элемента.

<h6>5.3.1.5.3 Использование потомков</h6>

Попробуем найти ввод цвета (Colour) на странице HTML5 Form Elements Test Page[^24].

Можно написать следующий локатор элемента: “.page-body .centered .form-label [name="colour"]”.



<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image14.png "image_tooltip")

Рисунок 14. Поиск с использованием потомков.

Пробел является значащим в CSS-селекторах, это разделитель предка и потомка. Потомок может находиться на любом уровне
вложенности, так например все элементы с классом “centered” являются потомками класса “page-body”.

<h4>5.3.2 Поиск элементов с помощью XPath</h4>

XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа.[^25] Это мощный и
гибкий инструмент, который позволяет использовать сложные поисковые запросы для нахождения нужного элемента.

Разберём кратко особенности синтаксиса XPath.

1. XPath запрос всегда начинается с символа “/” или “//”.

Символ “/” аналогичен символу “>” в CSS-селекторе, а символ “//” - пробелу.

Разница в том, что когда мы используем символ “/” в XPath локаторе, то мы всегда обязаны указывать корень документа. У
html страницы корнем всегда будет элемент с тегом “<html>”.

Мы можем начать XPath запрос с символа “//” - это будет означать, что мы хотим найти всех потомков корневого элемента
без его указания.

2. Квадратные скобки “[ ]” - это команда фильтрации в XPath.

Некоторые правила фильтрации, которые могут вам пригодится в составлении XPath-селекторов рассмотрим на примере страницы
DEMOQA Practice Form[^26].

* По любому атрибуту будь то class, name, type или любой другой. Например, нам нужна кнопка “Submit”:
  “//button[@type="submit"]”.
* По порядковому номеру. Допустим нам необходимо найти радиобаттон женского пола в форме для активации. Для этого
  подойдет следующий локатор: “//div[@id="genterWrapper"]/div/div[2]/input”, где “[2]” будет означать, что из списка
  элементов, которые подходят под данный локатор необходимо выбрать второй по счёту.
* По частичному совпадению. Мы можем найти элемент по внутреннему тексту, который расположен внутри него используя
  функцию “text()”. Давайте найдём таким методом кнопку “Submit”: “//button[contains(text(), "Submit")]”. Также этот
  метод подойдет для поиска частичного совпадения атрибутов, например, для поиска поля ввода текущего адреса:
  “//textarea[contains(@class, "form")]”. Обратите внимание, что класса “form” нет у поля ввода адреса, но есть класс
  “form-control”, который и нашёл наш селектор.

3. Символ “*” - команда выбора всех элементов.

Может быть удобна для выбора всех интересующих нас элементов или когда точно неизвестен тег элемента для поиска:
“//div/*[@class="form-control"]”

4. Поиск по классам с помощью XPath регистрозависим также как и в CSS-селекторах.

Поиск по локатору “//div/*[@class="Form-control"]” не даст результатов.

Мы рассмотрели базовые селекторы, которых будет достаточно для написания простых UI-тестов.

<h3>5.4 Поиск элементов с помощью Selenium WebDriver</h3>

<h4>5.4.1 Поиск элементов с помощью Selenium</h4>

Для поиска элементов на странице в Selenium WebDriver используются несколько методов, позволяющих искать по
CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод “find_element”, который принимает два
аргумента - тип локатора и значение локатора.

Существуют следующие методы поиска элементов:

* “find_element(By.ID, value)” - поиск по уникальному атрибуту “id” элемента;
* “find_element(By.CSS_SELECTOR, value)” - поиск элемента с помощью правил на основе CSS;
* “find_element(By.XPATH, value)” - поиск с помощью языка запросов XPath;
* “find_element(By.NAME, value)” - поиск по атрибуту name элемента;
* “find_element(By.TAG_NAME, value)” - поиск элемента по названию тега элемента;
* “find_element(By.CLASS_NAME, value)” - поиск по значению атрибута class;
* “find_element(By.LINK_TEXT, value)” - поиск ссылки на странице по полному совпадению;
* “find_element(By.PARTIAL_LINK_TEXT, value)” - поиск ссылки на странице, если текст селектора совпадает с любой частью
  текста ссылки.

На практике используются “find_element(By.CSS_SELECTOR, value)” и “find_element(By.XPATH, value)” чаще всего, изменяя
только значение.

Давайте найдем кнопку “Submit” на странице DEMOQA Text Box[^27].

Сперва заходим на сайт и находим уникальный селектор для кнопки. Нам повезло и у кнопки есть атрибут “id”: “id="
submit"”.

Посмотрим на код:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>browser.get('https://demoqa.com/text-box')</code>
6. <code>button = browser.find_element(By.CSS_SELECTOR, '#submit')</code>
7. <code> </code>

Класс By содержит все возможные локаторы. Вы можете использовать какой-нибудь другой.

Поиск нескольких элементов.

Вы можете столкнуться с ситуацией, когда вам нужно получить сразу несколько элементов или собрать коллекцию похожих
элементов для выполнения с ними каких-либо операций. Для этих целей есть метод “find_elements()”, который мы рассмотрим
чуть позже.

<h4>5.4.2 Работа с браузером в Selenium</h4>

Если вы запускаете примеры кода в своей среде разработке, то скорее всего вы задались вопросом о причине закрытия
браузера, хотя явного закрытия браузера в коде нет. Дело в работе сборщика мусора Python, который делает это за нас. Но
все же правильным будет указывать явно закрытие браузера.

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>link = 'https://demoqa.com/buttons'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(link)</code>
7. <code>click_me_button = browser.find_element(By.CSS_SELECTOR, '.col-md-6 div:nth-child(3) button')</code>
8. <code>click_me_button.click()</code>
9. <code> </code>
10. <code><em># закрываем браузер после всех манипуляций</em></code>
11. <code>browser.quit()</code>
12. <code> </code>

Но что произойдёт, если до момента закрытия браузера возникнет ошибка?

Один из подходов к решению этой проблемы - это использование конструкции “try/finally”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>link = 'https://demoqa.com/buttons'</code>
5. <strong><code>try:</code></strong>
6. <code>   browser = webdriver.Chrome()</code>
7. <code>   browser.get(link)</code>
8. <code>   click_me_button = browser.find_element(By.CSS_SELECTOR, '.col-md-6 div:nth-child(3) button')</code>
9. <code>   click_me_button.click()</code>
10. <strong><code>finally:</code></strong>
11. <code>   <em># закрываем браузер после всех манипуляций</em></code>
12. <code>   browser.quit()</code>
13. <code> </code>

<h5>5.4.2.1 Поиск всех необходимых элементов.</h5>

Допустим вам необходимо убедиться, что присутствуют все девять элементов содержащие гиперссылки на странице DEMOQA
Links[^28]. Для этого вы можете использовать метод “find_elements()” и написать следующий код:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>page = 'https://demoqa.com/links'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(page)</code>
7. <code> </code>
8. <code>link_locator = (By.CSS_SELECTOR, '#linkWrapper p a')</code>
9. <code> </code>
10. <code>links = browser.find_elements(*link_locator)</code>
11. <code>number_of_links = len(links)</code>
12. <code> </code>
13. <code>browser.quit()</code>
14. <code> </code>
15. <code><em># Проверяем, что количество ссылок на странице равно 9.</em></code>
16. <strong><code>assert number_of_links == 9</code></strong>
17. <code> </code>

Отметим несколько важных моментов касательно поиска элементов.

* Идеальный селекто - это уникальный селектор, который идентифицирует один конкретный элемент на странице.
* Эффективные автотесты - тесты, сосредоточенные на проверки отдельных функциональных единиц. Не стоит писать большие
  тестовые сценарии, так как простые тесты легче читаются вашими коллегами и позволяют быстро найти проблему, если один
  из тестов упадёт.
* Использование метода “sleep()” из библиотеки “time” для ожидания загрузки или изменения свойств элементов считается
  плохой практикой, так как заранее сложно спрогнозировать время ожидания, которое зависит от большого числа внешних
  факторов. Мы ещё вернёмся к решению этого вопроса более красивыми методами, а пока вы можете использовать
  “time.sleep()” для наглядности.

<h2>Глава 6. Полезные методы Selenium</h2>

<h3>6.1 Как работать с элементами типа checkbox и radiobutton?</h3>

Checkbox (чекбокс) и radiobutton (радиобаттон или переключатель) — часто используемые в формах элементы. Основная
разница между ними состоит в том, что чекбоксы позволяют выбирать/отключать любой из представленных вариантов, а
переключатели позволяют выбрать только один из вариантов. Далее мы будем называть эти элементы на англоязычный манер:
checkbox и radiobutton.

Оба этих элемента создаются при помощи тега `input` со значением атрибута `type` равным “checkbox” или “radio”
соответственно. В html-коде DEMOQA Practice Form[^29] страницы вы увидите:

<**input** name="gender" required="" type="radio" id="gender-radio-1" class="custom-control-input" value="Male">

<**input** type="checkbox" id="hobbies-checkbox-1" class="custom-control-input" value="1">

Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута “name”, но разные значения
атрибута “value”:

<**input** name="gender" required="" type="radio" id="gender-radio-1" class="custom-control-input" value="Male">

<**input** name="gender" required="" type="radio" id="gender-radio-2" class="custom-control-input" value="Female">

<**input** name="gender" required="" type="radio" id="gender-radio-3" class="custom-control-input" value="Other">

Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с
помощью значения “id” или значения атрибута “value”.

Чтобы выбрать элемент, необходимо кликнуть по нему, для этого необходимо использовать метод “click()” для найденного
элемента.

Пример выбора radiobutton пола Other в форме:

1. `gender_other_radio = browser.find_element(By.CSS_SELECTOR, "[value='Other']")`
2. `gender_other_radio.click()`

Рядом с радиобаттоном вы увидите тег “label”, который позволяет кликать по тексту. Текст заключен в тег “label”. Элемент
“label” связан с элементом ввода с помощью атрибута “for”, который соответствует значению атрибута “id” элемента ввода:

1. <code><<strong>div</strong> class="custom-control custom-radio custom-control-inline"></code>
2. <code>   <<strong>input</strong> name="gender" required="" type="radio" id="gender-radio-2" class="custom-control-input"</code>
3. <code>   value="Female"></code>
4. <code>   <<strong>label</strong> title="" for="gender-radio-2" class="custom-control-label">Female</<strong>label</strong>></code>
5. <code></<strong>div</strong>></code>

Раз текст радиобаттона кликабельный, то можно использовать метод “click()” на нём.

<h3>6.2 Метод get_attribute()</h3>

Для более детальный проверок в тестах нам может потребоваться получать значение атрибутов HTML. Атрибуты могут быть как
стандартными, например: alt, color, placeholder и другими, так и созданными разработчиками для задания собственных
стилей или правил. Подробнее ознакомиться со стандартным списком HTML атрибутов вы сможете в статье HTML Attribute
Reference[^30].

Давайте посмотрим на страницу DEMOQA Links[^31] ещё раз. На этой странице есть ссылки, которые ведут на другие страницы
и ссылки, которые отправляют запросы к API. Допустим, что нам необходимо проверить, что ссылка “Home” действительно
содержит ссылку на домашнюю страницу сайта. Для этого посмотрим на оформление HTML-кода элемента:

<**a** id="simpleLink" href="https://demoqa.com" target="_blank">Home</**a**>

Атрибут “href” определяет URL страницы, на которую ведёт ссылка. Чтобы получить этот или любой другой атрибут нам
необходимо воспользоваться методом get_attribute() для найденного элемента.

Давайте попробуем написать тест, который будет проверять корректность указанного URL у ссылки “Home”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>page = 'https://demoqa.com/links'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(page)</code>
7. <code> </code>
8. <code>home_link_locator = (By.CSS_SELECTOR, '#simpleLink')</code>
9. <code> </code>
10. <code>home_link = browser.find_element(*home_link_locator)</code>
11. <code>home_link_href = home_link.get_attribute('href')</code>
12. <code> </code>
13. <code>browser.quit()</code>
14. <code> </code>
15. <code><em># Проверяем, что ссылка у ссылки именно та, что должна быть.</em></code>
16. <strong><code>assert home_link_href == 'https://demoqa.com/'</code></strong>
17. <code> </code>

Хорошей практикой является написание подробного сообщения об ошибке при проверке, чтобы сразу стало понятно, что пошло
не так. Давайте напишем заведомо провальный тест с подробным описанием для проверки плейсхолдера в поле ввода “Full
Name” на странице DEMOQA Text Box[^32].

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>page = 'https://demoqa.com/text-box'</code>
5. <code>browser = webdriver.Chrome()</code>
6. <code>browser.get(page)</code>
7. <code> </code>
8. <code>full_name_field_locator = (By.CSS_SELECTOR, '#userName')</code>
9. <code> </code>
10. <code>full_name_field = browser.find_element(*full_name_field_locator)</code>
11. <code>full_name_field_placeholder = full_name_field.get_attribute('placeholder')</code>
12. <code>expected_full_name_field_placeholder = 'Current Address'</code>
13. <code> </code>
14. <code>browser.quit()</code>
15. <code> </code>
16. <strong><code>assert full_name_field_placeholder == expected_full_name_field_placeholder, \</code></strong>
17. <code>   f'Expected {expected_full_name_field_placeholder=}.' \</code>
18. <code>   f'<strong>\n</strong>Got: {full_name_field_placeholder=}'</code>
19. <code> </code>

При запуске такого теста вы получите “AssertionError”, так как плейсхолдер будет получен не тот, что вы написали в
ожидаемом результате:

1. <code>test_full_name_placeholder.py:None <strong>(</strong>test_full_name_placeholder.py<strong>)</strong></code>
2. <code>test_full_name_placeholder.py:16: <strong>in</strong> <strong><</strong>module<strong>></strong></code>
3. <code>   assert full_name_field_placeholder == expected_full_name_field_placeholder, \</code>
4. <code>E AssertionError: Expected expected_full_name_field_placeholder='Current Address'.</code>
5. <code>E Got: full_name_field_placeholder='Full Name'</code>
6. <code>E assert 'Full Name' == 'Current Address'</code>

Мы использовали форматирование строк и подробное описание ожидаемого и фактического результата в нашем тесте. Теперь,
будет легко понять, что за ошибка произошла при выполнении тестового скрипта. Следует отметить, что нарочитое
проваливание написанных тестов - это одна из хороших практик при написании тестовых сценариев, которой вы должны всегда
придерживаться. Следует обращать внимание на то, что тест действительно проваливается при неверных входных данных и
понятность сообщения об ошибке.

<h3>6.3 Работа с файлами, списками и js-скриптами</h3>

<h4>6.3.1 Работа со списками</h4>

На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных
особенностей:

* у каждого элемента списка обычно есть уникальное значение атрибута “value”;
* в списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка.

Давайте посмотрим как выглядит выпадающий список “Old Style Select Menu” в HTML-коде на странице DEMOQA Select
Menu[^33]:

<**select** id="oldSelectMenu">

    <**option** value="red">Red</**option**>

    <**option** value="1">Blue</**option**>

    <**option** value="2">Green</**option**>

    <**option** value="3">Yellow</**option**>

    <**option** value="4">Purple</**option**>

    <**option** value="5">Black</**option**>

    <**option** value="6">White</**option**>

    <**option** value="7">Voilet</**option**>

    <**option** value="8">Indigo</**option**>

    <**option** value="9">Magenta</**option**>

    <**option** value="10">Aqua</**option**>

</**select**>

Варианты ответа задаются тегом “option”, значение “value” может отсутствовать.

Давайте воспользуемся привычным уже нам методом “click()” для выбора ответа. Для этого сперва нам нужно раскрыть
выпадающий список кликнув на “select” и затем уже кликнуть на один из вариантов.

Код может быть следующим:

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>page_link = 'https://demoqa.com/select-menu'</code>
6. <code>browser = webdriver.Chrome()</code>
7. <code>browser.get(page_link)</code>
8. <code> </code>
9. <code>old_style_select_menu_locator = (By.CSS_SELECTOR, '#oldSelectMenu')</code>
10. <code>purple_color_locator = (By.CSS_SELECTOR, 'option:nth-child(5)')</code>
11. <code> </code>
12. <code>browser.find_element(*old_style_select_menu_locator).click()</code>
13. <code>sleep(1)</code>
14. <code>browser.find_element(*purple_color_locator).click()</code>
15. <code>sleep(1)</code>
16. <code> </code>

Есть более удобный способ, для которого используется специальный класс “Select” из библиотеки “WebDriver”. Вначале мы
должны инициализировать новый объект. Далее можно найти любой вариант из списка с помощью метода “select_by_value()”:

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <strong><code>from selenium.webdriver.support.ui import Select</code></strong>
5. <code> </code>
6. <code>page_link = 'https://demoqa.com/select-menu'</code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>browser.get(page_link)</code>
9. <code> </code>
10. <code>old_style_select_menu_locator = (By.CSS_SELECTOR, '#oldSelectMenu')</code>
11. <code>select = Select(browser.find_element(*old_style_select_menu_locator))</code>
12. <code>select.select_by_value('4')</code>
13. <code>sleep(1)</code>
14. <code> </code>

Есть ещё два метода “select_by_index()” и “select_by_visible_text()”. Первый ищет по индексу элемента и индексация
начинается с нуля, а второй по видимому тексту.

<h4>6.3.2 Метод execute_script()</h4>

Вот еще один метод, одновременно мощный и очень полезный, хотя и требующий некоторых базовых знаний JavaScript. Метод
“execute_script()” позволяет запускать код JavaScript в браузере при выполнении скрипта автоматизированного
тестирования. Хотя сначала это может показаться ненужным, поскольку автоматические тесты обычно взаимодействуют с
интерфейсом веб-сайта так же, как обычный пользователь, нажимая кнопки, выбирая пункты меню и вводя текст в поля, бывают
ситуации, когда выполнение JavaScript может быть невероятно полезным.

Стандартные методы Selenium могут оказаться недостаточными для всех сценариев веб-приложений. Веб-сайты сильно
различаются по назначению: от простых блогов до сложных финансовых или графических приложений. Разработчики имеют доступ
к огромному количеству библиотек для решения бизнес-сценариев, включая нестандартные текстовые редакторы, уникальные
меню и оригинальные видеоплееры на веб-страницах. В некоторых случаях тестировщикам может потребоваться написать скрипт
JavaScript для взаимодействия с, казалось бы, обычными кнопками. Когда это происходит, важно обратиться за помощью к
фронтэнд-разработчикам и попросить пример желаемого сценария. Тестировщики могут протестировать скрипт, выполнив его в
консоли браузера перед добавлением в автотест с помощью метода “execute_script(javascript_code)”.

Давайте попробуем вызвать “alert” в браузере с помощью WebDriver. Пример сценария:

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>browser.execute_script("alert('Hello world!');")</code>
6. <code>sleep(2)</code>
7. <code> </code>

Очень часто вы будете сталкиваться с ситуацией, когда вам нужно кликнуть на элемент, который есть на странице, но
необходимо проскроллить страницу, чтобы элемент стал видимым и скрипт сработал. Для этого вам потребуется использовать
код JavaScript: “return arguments[0].scrollIntoView(true);”.

Но давайте рассмотрим пример поинтереснее. Возьмём страницу DEMOQA Practice Form[^34] и попробуем нажать на кнопку
“Submit”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>practice_form_page_link = "https://demoqa.com/automation-practice-form"</code>
6. <code>browser.get(practice_form_page_link)</code>
7. <code> </code>
8. <code><em># browser.execute_script('document.getElementsByTagName(\'footer\')[0].remove();',
   practice_form_page_link)</em></code>
9. <code><em># browser.execute_script('document.getElementById(\'close-fixedban\').remove();')</em></code>
10. <code>submit_button = browser.find_element(By.CSS_SELECTOR, "#submit")</code>
11. <code>submit_button.click()</code>
12. <code> </code>

Получим исключение “ElementClickInterceptedException”, потому что у нас на странице дефект и футер перекрывает кнопку
“Submit”. Для того чтобы проверить работу формы и обойти этот дефект мы можем удалить элемент с помощью JavaScript
скрипта. Раскомментируйте восьмую и девятую строчки кода и перезапустите тест.

<h4>6.3.3 Загрузка файлов</h4>

Если нам понадобится загрузить файл на веб-странице, мы можем использовать уже знакомый нам метод “send_keys”. Только
теперь нам нужно в качестве аргумента передать путь к нужному файлу на диске вместо простого текста.

Чтобы указать путь к файлу, можно использовать стандартный модуль Python для работы с операционной системой — os. В этом
случае ваш код не будет зависеть от операционной системы, которую вы используете. Добавление файла будет работать и на
Windows, и на Linux, и даже на MaсOS.

Пример кода для загрузки файла на сайт:

1. **<code>from os import path, remove</code></strong>
2. <strong><code>from time import sleep</code></strong>
3. <strong><code>from random import randint</code></strong>
4. <strong><code>from selenium import webdriver</code></strong>
5. <strong><code>from selenium.webdriver.common.by import By</code></strong>
6. <code> </code>
7. <code> </code>
8. <strong><code>def generated_file() -> tuple[str, str]:</code></strong>
9. <code>   """</code>
10. <code>   File generation.</code>
11. <code>   :returns: file name and absolute path.</code>
12. <code>   """</code>
13. <code>   file_path = f'filetest{randint(0, 999)}.txt'</code>
14. <code>   <strong>with</strong> open(file_path, 'w+', encoding='UTF-8') <strong>as</strong> file:</code>
15. <code>       file.write(f'Hello, world!{randint(0, 999)}')</code>
16. <code>   <strong>return</strong> file.name, path.abspath(file_path)</code>
17. <code> </code>
18. <code> </code>
19. <code>browser = webdriver.Chrome()</code>
20. <code>upload_and_download_page_link = 'https://demoqa.com/upload-download'</code>
21. <code>browser.get(upload_and_download_page_link)</code>
22. <code> </code>
23. <code>file_name, file_path = generated_file()</code>
24. <code> </code>
25. <code>upload_button_locator = (By.CSS_SELECTOR, '#uploadFile')</code>
26. <code>upload_button = browser.find_element(*upload_button_locator)</code>
27. <code>upload_button.send_keys(file_path)</code>
28. <code>remove(file_path)</code>
29. <code>sleep(3)</code>
30. <code> </code>

<h4>6.3.4 Работа с окнами</h4>

<h5>6.3.4.1 Alerts</h5>

Мы уже сталкивались с разными видами уведомлений, но не писали тестовые сценарии для их проверки. Предположим нам надо
проверить содержание alert-а и нажать на кнопку “ОК”, чтобы его закрыть. Для того, чтобы закрыть предупреждение, скрипт
должен сначала переключиться в окно alert-а, а затем использовать команду “accept()”.

Давайте напишем небольшой тестовый сценарий для страницы DEMOQA Alerts[^35]:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>browser = webdriver.Chrome()</code>
5. <code>alerts_page_link = 'https://demoqa.com/alerts'</code>
6. <code>browser.get(alerts_page_link)</code>
7. <code> </code>
8. <code>alert_button_locator = (By.CSS_SELECTOR, '#alertButton')</code>
9. <code>alert_button = browser.find_element(*alert_button_locator)</code>
10. <code>alert_button.click()</code>
11. <code>alert = browser.switch_to.alert</code>
12. <code> </code>
13. <code>alert_text = alert.text</code>
14. <code>expected_alert_text = 'You clicked a button'</code>
15. <code>alert.accept()</code>
16. <code> </code>
17. <strong><code>assert alert_text == expected_alert_text, \</code></strong>
18. <code>   f'Expected alert text to be {expected_alert_text}.' \</code>
19. <code>   f'<strong>\n</strong> Got {alert_text} instead.'</code>
20. <code> </code>

Следующий тип модального окна - confirm отличается от alert тем, что его можно либо принять, либо отменить. Чтобы
принять нужно использовать метод “accept()”, чтобы отменить - метод “dismiss()”.

Третий тип модального окна - “prompt” - имеет дополнительное поле для ввода текста. Чтобы ввести текст, нужно
использовать уже знакомый нам метод “send_keys()”.

Давайте напишем тестовый сценарий для проверки текста, который мы введём в модальном окне prompt. Сначала проделайте
такой тест вручную: вызовите prompt, введите текст, нажмите кнопку “ОК”, проверьте текст расположенный слева от
prompt-а, там будет введённый текст сообщения. Теперь попробуем автоматизировать этот тестовый сценарий:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>prompt_button_locator = (By.XPATH, '//button[@id="promtButton"]')</code>
5. <code>prompt_result_locator = (By.XPATH, '//span[@id="promptResult"]')</code>
6. <code> </code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>alerts_page_link = 'https://demoqa.com/alerts'</code>
9. <code>browser.get(alerts_page_link)</code>
10. <code> </code>
11. <code>prompt_button = browser.find_element(*prompt_button_locator)</code>
12. <code>prompt_button.click()</code>
13. <code> </code>
14. <code>prompt = browser.switch_to.alert</code>
15. <code>input_text_to_prompt = 'Hello_world!'</code>
16. <code>prompt.send_keys(input_text_to_prompt)</code>
17. <code>prompt.accept()</code>
18. <code> </code>
19. <code>prompt_result = browser.find_element(*prompt_result_locator)</code>
20. <code>prompt_result_text = prompt_result.text.split()[-1]</code>
21. <code> </code>
22. <strong><code>assert prompt_result_text == input_text_to_prompt, \</code></strong>
23. <code>   f'Entered text to prompt was {input_text_to_prompt}' \</code>
24. <code>   f'<strong>\n</strong> Expected equal to {prompt_result_text=}.'</code>
25. <code> </code>

<h5>6.3.4.2 Переход на новую вкладку в браузере</h5>

При работе с веб-приложениями часто встречаются ссылки, которые открываются в новой вкладке браузера. Однако WebDriver
может одновременно взаимодействовать только с одной вкладкой браузера. Когда ссылка открывается в новой вкладке,
WebDriver продолжит работу на старой вкладке. Чтобы переключиться на только что открытую вкладку, нам нужно явно
указать, с какой вкладкой мы хотим работать. Этого можно добиться с помощью команды “switch_to.window”:
“browser.switch_to.window(window_name)”.

Чтобы определить имя вновь открытой вкладки, можно использовать метод “window_handles”, который возвращает массив имен
всех вкладок. Как только мы подтвердим, что две вкладки открыты, мы можем переключиться на вторую вкладку, используя
соответствующую индексацию: “new_window = browser.window_handles[1]“.

Давайте напишем тестовый сценарий страницы DEMOQA Browser Windows для открытия новой вкладки по нажатию по кнопке “New
Tab”:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>new_tab_button_locator = (By.CSS_SELECTOR, '#tabButton')</code>
5. <code>sample_text_locator = (By.CSS_SELECTOR, '#sampleHeading')</code>
6. <code> </code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>browser_windows_page_link = 'https://demoqa.com/browser-windows'</code>
9. <code>browser.get(browser_windows_page_link)</code>
10. <code> </code>
11. <code>new_tab_button = browser.find_element(*new_tab_button_locator)</code>
12. <code>new_tab_button.click()</code>
13. <code> </code>
14. <code>browser.switch_to.window(browser.window_handles[1])</code>
15. <code> </code>
16. <code>sample_text_element = browser.find_element(*sample_text_locator)</code>
17. <code>actual_sample_text = sample_text_element.text</code>
18. <code>expected_sample_text = 'This is a sample page'</code>
19. <code> </code>
20. <strong><code>assert actual_sample_text == expected_sample_text, \</code></strong>
21. <code>   f'Expected {expected_sample_text=} in new tab ' \</code>
22. <code>   f'to be equal to {actual_sample_text=}.'</code>
23. <code> </code>

<h3>6.4 Настройка ожиданий</h3>

Разработчики усердно работали над созданием красивых и быстро загружаемых веб-страниц с плавными переходами между ними.

Это было достигнуто за счет использования подхода одностраничных приложений (SPA), когда сайт имеет только одну
страницу, а ее содержимое динамически обновляется с помощью JavaScript, который обменивается информацией с сервером
через REST API.

Хотя этот подход обеспечивает удобство работы с пользователем, он создает проблемы для тех, кто создает UI автотесты.
Непредсказуемое появление или исчезновение элементов на странице, непредсказуемое время рендеринга и изменение текста в
кнопках или сообщениях — вот некоторые особенности приложений SPA, которые необходимо учитывать при автотестировании.
Это один из самых сложных и запутанных аспектов разработки автотестов в Selenium (и других фреймворках для E-2-E (
end-to-end) тестов).

Мы рассмотрим эти распространенные проблемы и узнаем, как их преодолеть.

<h4>6.4.1 Работа методов get() и find_element()</h4>

Допустим, нам надо проверить, что на странице DEMOQA Dynamic Properties[^36] кнопку “Visible After 5 Seconds” можно
кликнуть.

Тестовый сценарий:

1. зайти на страницу;
2. кликнуть по кнопке.

Открываем страницу с помощью метода “get()”, ищем элемент методом “find_element()” и кликаем по кнопке с помощью метода
“click()”.

Вот как выглядит код автотеста:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
5. <code> </code>
6. <code>browser = webdriver.Chrome()</code>
7. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
8. <code>browser.get(dynamic_properties_page_link)</code>
9. <code> </code>
10. <code>visiable_after_five_sec_button = browser.find_element(*visiable_after_five_sec_button_locator)</code>
11. <code>visiable_after_five_sec_button.click()</code>
12. <code> </code>

Сперва попробуйте выполнить тест вручную, а затем переходите к автотесту. Когда вы будете проходить тест самостоятельно
вы заметите, что кнопка появляется с задержкой. И в случае запуска автотеста вы получите ошибку
“NoSuchElementException”, потому что автотест пытается найти кнопку, которая ещё не видна.

Такая ситуация часто происходит на страницах использующих JavaScript, что очень вероятно для современных сайтов.

<h4>6.4.2. Использование time.sleep()</h4>

Поскольку мы знаем о задержке появления кнопки, мы можем добавить паузу в наш тестовый сценарий перед поиском элемента.
Воспользуемся библиотекой “time”.

1. **<code>from time import sleep</code></strong>
2. <strong><code>from selenium import webdriver</code></strong>
3. <strong><code>from selenium.webdriver.common.by import By</code></strong>
4. <code> </code>
5. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
6. <code> </code>
7. <code>browser = webdriver.Chrome()</code>
8. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
9. <code>browser.get(dynamic_properties_page_link)</code>
10. <code> </code>
11. <code>sleep(5)</code>
12. <code>visiable_after_five_sec_button = browser.find_element(*visiable_after_five_sec_button_locator)</code>
13. <code>visiable_after_five_sec_button.click()</code>
14. <code> </code>

Текущее решение добавления фиксированной задержки перед поиском элемента может быть неэффективным при обработке
различных сценариев. Например, если элемент с сообщением тоже появляется с задержкой, или время задержки меняется при
появлении кнопки. Точно так же скорость Интернета на разных машинах может вызывать различия во временном интервале,
когда появляется кнопка. Хотя добавление задержки перед каждым действием может показаться решением, это непрактично, так
как может излишне увеличить время выполнения теста. С увеличением количества тестов эта проблема будет только
усугубляться.

<h4>6.4.3 Использование Selenium Waits (Implicit Waits)</h4>

Решение с time.sleep() плохое: оно не масштабируемое и трудно поддерживаемое.

Лучший способ справиться с ложными ошибками теста, вызванными асинхронным выполнением сценариев или задержками
сервера, — реализовать решение, которое ожидает появления определенного элемента на странице в течение заданного периода
времени (например, 5 секунд). Мы можем проверять наличие элемента каждые 500 миллисекунд, и как только элемент будет
найден, мы можем сразу перейти к следующему шагу теста. Таким образом, мы можем получить желаемый элемент как можно
скорее в лучшем случае или в течение 5 секунд в худшем случае.

Selenium WebDriver предоставляет особый подход к обработке этого ожидания, который позволяет нам установить ожидание во
время инициализации драйвера и применить его ко всем тестам. Это ожидание называется неявным ожиданием, поскольку нам не
нужно явно указывать его каждый раз, когда мы ищем элементы. Он будет автоматически применяться к каждой последующей
команде.

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <code> </code>
4. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
5. <code> </code>
6. <code>browser = webdriver.Chrome()</code>
7. <code>browser.implicitly_wait(5)</code>
8. <code> </code>
9. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
10. <code>browser.get(dynamic_properties_page_link)</code>
11. <code> </code>
12. <code>visiable_after_five_sec_button = browser.find_element(*visiable_after_five_sec_button_locator)</code>
13. <code>visiable_after_five_sec_button.click()</code>
14. <code> </code>

С неявным ожиданием, установленным во время инициализации драйвера, мы можем гарантировать, что наши тесты останутся
стабильными даже при незначительных задержках на веб-сайте. Для каждого экземпляра команды “find_element” WebDriver
будет ждать до 5 секунд, пока элемент появится на странице, прежде чем вызвать исключение “NoSuchElementException”.

<h4>6.4.4 Использование Explicit Waits (WebDriverWait и expected_conditions)</h4>

Для обеспечения надежности нашего теста мы должны убедиться, что наша кнопка не только появилась, но и является
кликабельной. На страницах часто бывает, что кнопки загружаются перед тем, как стать доступными для клика. Наш
предыдущий вариант теста с неявным ожиданием не будет дожидаться до активации элемента и тест упадет с ошибкой.

Давайте улучшим наш тест с использованием явных ожиданий и ожидаемых условий:

1. **<code>from selenium import webdriver</code></strong>
2. <strong><code>from selenium.webdriver.common.by import By</code></strong>
3. <strong><code>from selenium.webdriver.support.ui import WebDriverWait as wait</code></strong>
4. <strong><code>from selenium.webdriver.support import expected_conditions as EC</code></strong>
5. <code> </code>
6. <code>visiable_after_five_sec_button_locator = (By.CSS_SELECTOR, '#visibleAfter')</code>
7. <code> </code>
8. <code>browser = webdriver.Chrome()</code>
9. <code> </code>
10. <code>dynamic_properties_page_link = 'https://demoqa.com/dynamic-properties'</code>
11. <code>browser.get(dynamic_properties_page_link)</code>
12. <code> </code>
13. <code>visiable_after_five_sec_button = wait(browser, 5).until(</code>
14. <code>   EC.element_to_be_clickable(visiable_after_five_sec_button_locator))</code>
15. <code>visiable_after_five_sec_button.click()</code>
16. <code> </code>

Следует отметить, что “element_to_be_clickable()” вернёт элемент, когда он будет кликабельный или False в противном
случае.

Модуль “expected_conditions” имеет несколько других условий, которые можно использовать для определения ожиданий, с ними
можно ознакомиться в спецификации[^37].

<h2>Глава 7. Тестовые фреймворки</h2>

<h2>Литература</h2>

Куликов, С. С. Тестирование программного обеспечения. Базовый курс. (3-е издание) / С. С. Куликов. – Newtown,
Pennsylvania : EPAM Systems, 2023. – 301 с. –
URL: [https://svyatoslav.biz/software_testing_book/](https://svyatoslav.biz/software_testing_book/) (дата обращения:
20.03.2023). – Режим доступа: свободный

Тестирование программного обеспечения // Wikipedia : сайт. –
URL: [https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения](https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения) (
дата обращения: 20.03.2023)

ISTQB Glossary : сайт. –
URL: [https://glossary.istqb.org/en_US/term/testing-4-2](https://glossary.istqb.org/en_US/term/testing-4-2) (дата
обращения: 20.03.2023)

Фундаментальная теория тестирования // Habr : сайт. –
URL: [https://habr.com/ru/articles/549054/](https://habr.com/ru/articles/549054/) (дата обращения: 20.03.2023)

Принципы тестирования: нас 7 // Habr : сайт. –
URL: [https://habr.com/ru/articles/699990/](https://habr.com/ru/articles/699990/) (дата обращения: 20.03.2023)

Основы HTML // MDN Web Docs : сайт. – URL: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/) (дата
обращения: 20.03.2023)

Основы CSS // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics](https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics) (
дата обращения: 21.03.2023

LearnGitBranching : сайт. –
URL: [https://learngitbranching.js.org/?locale=ru_RU](https://learngitbranching.js.org/?locale=ru_RU) (дата обращения:
28.03.2023)

Markdown-Cheatsheet // GitHub : сайт. –
URL: [https://github.com/Lexxx42/Markdown-Cheatsheet](https://github.com/Lexxx42/Markdown-Cheatsheet) (дата обращения:
29.03.2023)

Markdown Cheatsheet // GitHub : сайт. –
URL: [https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) (
дата обращения: 29.03.2023)

Download PyCharm: Python IDE for Professional Developers by JetBrains : сайт. –
URL: [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/) (дата обращения:
05.04.2023)

Download Python | Python.org : сайт. – URL: [https://www.python.org/downloads/](https://www.python.org/downloads/) (дата
обращения: 05.04.2023)

Statcounter Global Stats - Browser, OS, Search Engine including Mobile Usage Share : сайт. –
URL: [https://gs.statcounter.com/](https://gs.statcounter.com/) (дата обращения: 05.04.2023)

ChromeDriver - WebDriver for Chrome : сайт. –
URL: [https://chromedriver.chromium.org/](https://chromedriver.chromium.org/) (дата обращения: 05.04.2023)

Скачать chromedriver для автоматизации Google Chrome в Python : сайт. –
URL: [https://selenium-python.com/install-chromedriver-chrome](https://selenium-python.com/install-chromedriver-chrome) (
дата обращения: 05.04.2023)

DEMOQA : сайт. – URL: [https://demoqa.com/](https://demoqa.com/) (дата обращения: 05.04.2023)

Selenium Test Pages : сайт. –
URL: [https://testpages.herokuapp.com/styled/index.html](https://testpages.herokuapp.com/styled/index.html) (дата
обращения: 18.05.2023)

Инструменты разработчика // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools](https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools) (
дата обращения: 18.05.2023)

XPath // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/en-US/docs/Web/XPath](https://developer.mozilla.org/en-US/docs/Web/XPath) (дата
обращения: 06.04.2023)

HTML Attribute Reference // W3Schools Online Web Tutorials : сайт. –
URL: [https://www.w3schools.com/tags/ref_attributes.asp](https://www.w3schools.com/tags/ref_attributes.asp) (дата
обращения: 11.04.2023)

selenium.webdriver.support.expected_conditions // Selenium : сайт. –
URL: [https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html) (
дата обращения: 21.04.2023)


<!-- Footnotes themselves at the bottom. -->

## Notes

[^1]:
Тестирование программного обеспечения // Wikipedia : сайт. –
URL: [https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения](https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения) (
дата обращения: 20.03.2023)

[^2]:
Куликов, С. С. Тестирование программного обеспечения. Базовый курс. (3-е издание) / С. С. Куликов. – Newtown,
Pennsylvania : EPAM Systems, 2023. – 301 с. – URL: https://svyatoslav.biz/software_testing_book/ (дата обращения:
20.03.2023). – Режим доступа: свободный

[^3]:
ISTQB Glossary : сайт. –
URL: [https://glossary.istqb.org/en_US/term/testing-4-2](https://glossary.istqb.org/en_US/term/testing-4-2) (дата
обращения: 20.03.2023)

[^4]:
Фундаментальная теория тестирования // Habr : сайт. –
URL: [https://habr.com/ru/articles/549054/](https://habr.com/ru/articles/549054/) (дата обращения: 20.03.2023)

[^5]:
Принципы тестирования: нас 7 // Habr : сайт. –
URL: [https://habr.com/ru/articles/699990/](https://habr.com/ru/articles/699990/) (дата обращения: 20.03.2023)

[^6]:

     Основы HTML // MDN Web Docs : сайт. – URL: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/) (дата обращения: 20.03.2023)

[^7]:
Основы CSS // MDN Web Docs : сайт. –
URL: https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/CSS_basics (дата обращения: 21.03.2023)

[^8]:
LearnGitBranching : сайт. –
URL: [https://learngitbranching.js.org/?locale=ru_RU](https://learngitbranching.js.org/?locale=ru_RU) (дата обращения:
28.03.2023)

[^9]:
Markdown-Cheatsheet // GitHub : сайт. –
URL: [https://github.com/Lexxx42/Markdown-Cheatsheet](https://github.com/Lexxx42/Markdown-Cheatsheet) (дата обращения:
29.03.2023)

[^10]:
Markdown Cheatsheet // GitHub : сайт. –
URL: [https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) (
дата обращения: 29.03.2023)

[^11]:
Download PyCharm: Python IDE for Professional Developers by JetBrains : сайт. –
URL: [https://www.jetbrains.com/pycharm/download/](https://www.jetbrains.com/pycharm/download/) (дата обращения:
05.04.2023)

[^12]:
Download Python | Python.org : сайт. – URL: [https://www.python.org/downloads/](https://www.python.org/downloads/) (дата
обращения: 05.04.2023)

[^13]:
Statcounter Global Stats - Browser, OS, Search Engine including Mobile Usage Share : сайт. –
URL: [https://gs.statcounter.com/](https://gs.statcounter.com/) (дата обращения: 05.04.2023)

[^14]:
ChromeDriver - WebDriver for Chrome : сайт. –
URL: [https://chromedriver.chromium.org/](https://chromedriver.chromium.org/) (дата обращения: 05.04.2023)

[^15]:
Скачать chromedriver для автоматизации Google Chrome в Python : сайт. –
URL: [https://selenium-python.com/install-chromedriver-chrome](https://selenium-python.com/install-chromedriver-chrome) (
дата обращения: 05.04.2023)

[^16]:
DEMOQA : сайт. – URL: [https://demoqa.com/](https://demoqa.com/) (дата обращения: 05.04.2023)

[^17]:
Selenium Test Pages : сайт. –
URL: [https://testpages.herokuapp.com/styled/index.html](https://testpages.herokuapp.com/styled/index.html) (дата
обращения: 18.05.2023)

[^18]:
Basic Web Page Title : сайт. –
URL: [https://testpages.herokuapp.com/styled/basic-web-page-test.html](https://testpages.herokuapp.com/styled/basic-web-page-test.html) (
дата обращения: 18.05.2023)

[^19]:
Инструменты разработчика // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools](https://developer.mozilla.org/ru/docs/Glossary/Developer_Tools) (
дата обращения: 18.05.2023)

[^20]:
Basic Web Page Title : сайт. –
URL: [https://testpages.herokuapp.com/styled/basic-web-page-test.html](https://testpages.herokuapp.com/styled/basic-web-page-test.html) (
дата обращения: 18.05.2023)

[^21]:
Test Page For Element Attributes : сайт. –
URL: [https://testpages.herokuapp.com/styled/attributes-test.html](https://testpages.herokuapp.com/styled/attributes-test.html) (
дата обращения: 18.05.2023)

[^22]:
Windows Example Test : сайт. – URL: https://testpages.herokuapp.com/styled/windows-test.html (дата обращения:
18.05.2023)

[^23]:
Welcome to the Find By Playground : сайт. –
URL: [https://testpages.herokuapp.com/styled/find-by-playground-test.html](https://testpages.herokuapp.com/styled/find-by-playground-test.html) (
дата обращения: 18.05.2023)

[^24]:
HTML5 Form Elements Test Page : сайт. –
URL: [https://testpages.herokuapp.com/styled/html5-form-test.html](https://testpages.herokuapp.com/styled/html5-form-test.html) (
дата обращения: 18.05.2023)

[^25]:
XPath // MDN Web Docs : сайт. –
URL: [https://developer.mozilla.org/en-US/docs/Web/XPath](https://developer.mozilla.org/en-US/docs/Web/XPath) (дата
обращения: 06.04.2023)

[^26]:
DEMOQA Practice Form : сайт. –
URL: [https://demoqa.com/automation-practice-form](https://demoqa.com/automation-practice-form) (дата обращения:
18.05.2023)

[^27]:
DEMOQA Text Box : сайт. – URL: [https://demoqa.com/text-box](https://demoqa.com/text-box) (дата обращения: 18.05.2023)

[^28]:
DEMOQA Links : сайт. – URL: [https://demoqa.com/links](https://demoqa.com/links) (дата обращения: 18.05.2023)

[^29]:
DEMOQA Practice Form : сайт. –
URL: [https://demoqa.com/automation-practice-form](https://demoqa.com/automation-practice-form) (дата обращения:
18.05.2023)

[^30]:
HTML Attribute Reference // W3Schools Online Web Tutorials : сайт. –
URL: [https://www.w3schools.com/tags/ref_attributes.asp](https://www.w3schools.com/tags/ref_attributes.asp) (дата
обращения: 11.04.2023)

[^31]:
DEMOQA Links : сайт. – URL: [https://demoqa.com/links](https://demoqa.com/links) (дата обращения: 18.05.2023)

[^32]:
DEMOQA Text Box : сайт. – URL: [https://demoqa.com/text-box](https://demoqa.com/text-box) (дата обращения: 18.05.2023)

[^33]:
DEMOQA Select Menu : сайт. – URL: [https://demoqa.com/select-menu](https://demoqa.com/select-menu) (дата обращения:
19.05.2023)

[^34]:
DEMOQA Practice Form : сайт. –
URL: [https://demoqa.com/automation-practice-form](https://demoqa.com/automation-practice-form) (дата обращения:
18.05.2023)

[^35]:
DEMOQA Alerts : сайт. – URL: [https://demoqa.com/alerts](https://demoqa.com/alerts) (дата обращения: 19.05.2023)

[^36]:
DEMOQA Dynamic Properties : сайт. –
URL: [https://demoqa.com/dynamic-properties](https://demoqa.com/dynamic-properties) (дата обращения: 20.05.2023)

[^37]:
selenium.webdriver.support.expected_conditions // Selenium : сайт. –
URL: [https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html) (
дата обращения: 21.04.2023)
