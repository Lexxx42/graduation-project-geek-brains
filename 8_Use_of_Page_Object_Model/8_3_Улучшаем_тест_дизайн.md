# Улучшаем дизайн тестов

Вы уже знаете практически всю теорию о применении Page Object Model и далее будет много заданий на самостоятельное
выполнение. Вы будуте самостоятельно их делать и проверять себя. Это сильно увеличит эффективность усвоения
теоретических знаний и у вас появится проект, который можно будет продемонстрировать.

## Задание: добавление в корзину со страницы товара

Представим вам поручили автоматизировать следующий сценарий:

1. Открыть страницу `http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/?promo=newYear`.
2. Нажать на кнопку "Добавить товар".
3. Решить уравнение и получить скидку, ввести ответ. Для этого использовав метод `solve_quiz_and_get_code()`, который
   вам отдали уже реализованный.

Ожидаемый результат:

1. Получение сообщения, что товар добавлен в корзину. Название товара в сообщении соответствует добавленному товару в
   корзину.
2. Сообщение со стоимостью корзины, стоимость которой соответствует стоимости добавленного товара.

Тест нужно написать, используя паттерн Page Object. Для этого вам нужно:

1. Добавить новый файл для тест-кейсов, связанных со страницей товара. Например `test_product_page.py`.
2. Создать класс для страницы товара. Опишите его в файле `product_page.py` в директории `pages`.
3. Реализовать метод для добавления в корзину.
4. Реализовать методы-проверки.
5. Добавить локаторы к элементам страницы в отдельном классе файла `locators.py`.
6. Реализовать сам тест-кейс. Назовите тест `test_guest_can_add_product_to_basket`.

Хорошей практикой является создание новой ветки, отходящей от основной, в которой уже будет реализован новый функционал.
Так же рекомендуется сперва создавать структуру, а затем уже переходить к реализации. Например, сперва создаются пустые
файлы и прописываются импорты, затем описываются необходимые локаторы, после чего уже можно переходить к созданию
объекта страницы и методы-проверки, и только в самом конце писать тесты. Но вы можете выполнять шаги с любого пункта.

```python
from selenium.common.exceptions import NoAlertPresentException


def solve_quiz_and_get_code(self):
    alert = self.browser.switch_to.alert
    x = alert.text.split()[2]
    answer = str(math.log(abs((12 * math.sin(float(x))))))
    alert.send_keys(answer)
    alert.accept()
    try:
        alert = self.browser.switch_to.alert
        alert_text = alert.text
        print(f'Code: {alert_text}')
        alert.accept()
    except NoAlertPresentException:
        print('No second alert present')

```

Напомню, чтобы видеть результаты работы функции `print()` необходимо запускать Pytest с флагом `-s`.

## Задание: независимость от данных

Для эффективных автотестов крайне важно минимизировать зависимости от конкретных данных. Жесткие проверки объектов,
уникальных для конкретного экземпляра, настоятельно не рекомендуются. Почему? Что ж, данные имеют свойство часто
меняться, что потребует постоянных фиксов автотестов. Более того, такой подход затрудняет повторное использование
кода. Например, если мы собираемся запустить тест для нескольких продуктов, нам потребуется создать множество проверок,
по одной для каждого продукта. В конечном итоге такая практика снижает качество продукта, поскольку эти тесты охватывают
лишь ограниченное количество страниц.

Общая рекомендация состоит в том, чтобы убедиться, что ваши тесты не зависят от факторов, находящихся вне вашего
контроля. Сюда входят данные, хранящиеся в базах данных или сторонних службах, используемых вашим приложением.
Желательно избегать проверки конкретных данных, если у вас нет специально подготовленной тестовой базы данных, которая
инициализируется перед каждым запуском теста, или если вы можете добавить необходимые данные непосредственно в базу
данных или через API приложения. Осуществляя контроль над тестовой средой и данными, вы можете поддерживать более
надежные и воспроизводимые тесты.

Запустите тест, который мы написали на предыдущем этапе разработки, со
ссылкой: http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=newYear2019.

Если вы на прошлом шаге проверяли конкретное название товара, то ваш тест упадёт с ошибкой, так как теперь был добавлен
другой товар. Если тест прошел успешно, то вы написали тест независимый от контекста и правильно сделали.

Чтобы тест был независимым от контента:

* Измените методы проверки так, чтобы они принимали название товара и цену товара.
* Сделайте метод, который берёт из элемента название товара и возвращает его.
* Сделайте такой же метод для цены.
* Проверьте, что название товара в сообщении совпадает с заголовком товара.

Вот несколько основных советов, как добиться независимости тестов:

1. Используйте тестовые данные: вместо того, чтобы полагаться на конкретные данные, существующие в определенном
   контексте, иницциализируйте тестовые данные в самом тесте. Это гарантирует, что тест может выполняться с собственным
   набором данных независимо от контекста.

2. Избегайте "хардкодинга" значений: вместо "хардкодинга" конкретных значений или идентификаторов используйте
   переменные или константы в тестовом коде. Это обеспечивает гибкость при изменении значений без изменения логики
   тестирования.

3. Моделирование внешних зависимостей: если ваши тесты зависят от внешних систем или служб, рассмотрите возможность
   использования фиктивных (mock) фреймворков или методов для имитации этих зависимостей. Таким образом, ваши тесты
   могут выполняться независимо, не полагаясь на доступность или поведение внешних компонентов.

4. Изолируйте тестовые наборы: убедитесь, что каждый тестовый набор является автономным и не зависит от выполнения или
   результатов других тестовых наборов. Избегайте зависимостей между тестами.

5. Используйте методы setup и teardown: используйте методы настройки и очистки срезы, предоставляемые средами
   тестирования, для подготовки необходимой тестовой среды и очистки после теста. Это гарантирует, что каждый тест
   начинается с известного состояния и заканчивается приводя систему в исходное состояние.

6. Инкапсулируйте тестовую логику. Организуйте тестовый код в повторно используемые функции или классы, которые
   инкапсулируют тестовую логику. Это повышает читаемость, поддерживаемость и возможность повторного использования
   ваших тестов.

7. Избегайте зависимостей от внешних файлов конфигурации: если ваши тесты полагаются на файлы конфигурации, рассмотрите
   возможность предоставления специфичных для теста конфигураций в самом тестовом коде или с использованием методов
   имитации конфигурации.

## Задание: независимость контента, ищем баг

Теперь мы будем искать самый настоящий баг у нашего интерент-магазина.

Итак, вводная: была запущено несколько промо-акций, одна из которых приводит к появлению дефекта. Промо-акция включается
путем добавления параметра `?promo=offerN` к ссылке на товар.

На не придется писать отдельные тесты для каждой ссылки на промо-акцию, чтобы проверить её работоспособность, мы будем
использовать параметризацию. Вам нужно определить при каком значении параметра акции тест будет падать. Для этого мы
должны обнаружить проблемный URL, на котором возникает ошибка. Значение `N` у параметра `?promo=offerN` изменяется от 0
до 9.

Параметризация используется для запуска теста с разными входными данными. Вот пример, как вы можете использовать
декоратор параметризации:

```python
@pytest.mark.parametrize('link', ["http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer1",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer2",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer3",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer4",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer5",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer6",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer7",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer8",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer9"])
def test_guest_can_add_product_to_basket(browser, link):
    # ваша реализация теста

```

Скажем, что после обнаружения бага, вам сказал, что фиксить баг в этом спринте вы не будете. Вам необходимо отметить
тест, как ожидаемо падающий, использовав xfail. Мы уже говорили, как использовать эту фичу, вы можете осведить знания в
памяти [Skip/xfail with parametrize](https://pytest.org/en/stable/how-to/skipping.html#skip-xfail-with-parametrize).

Ваша задача:

1. Параметризовать тест.
2. Обнаружить дефект.
3. Пометить тест с дефектом, как ожидаемо падающий.
4. Зафиксировать изменения коммитом с осмысленным сообщением.











