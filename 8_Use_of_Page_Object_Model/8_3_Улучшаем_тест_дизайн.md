# Улучшаем дизайн тестов

Вы уже знаете практически всю теорию о применении Page Object Model и далее будет много заданий на самостоятельное
выполнение. Вы будуте самостоятельно их делать и проверять себя. Это сильно увеличит эффективность усвоения
теоретических знаний и у вас появится проект, который можно будет продемонстрировать.

## Задание: добавление в корзину со страницы товара

Представим вам поручили автоматизировать следующий сценарий:

1. Открыть страницу `http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/?promo=newYear`.
2. Нажать на кнопку "Добавить товар".
3. Решить уравнение и получить скидку, ввести ответ. Для этого использовав метод `solve_quiz_and_get_code()`, который
   вам отдали уже реализованный.

Ожидаемый результат:

1. Получение сообщения, что товар добавлен в корзину. Название товара в сообщении соответствует добавленному товару в
   корзину.
2. Сообщение со стоимостью корзины, стоимость которой соответствует стоимости добавленного товара.

Тест нужно написать, используя паттерн Page Object. Для этого вам нужно:

1. Добавить новый файл для тест-кейсов, связанных со страницей товара. Например `test_product_page.py`.
2. Создать класс для страницы товара. Опишите его в файле `product_page.py` в директории `pages`.
3. Реализовать метод для добавления в корзину.
4. Реализовать методы-проверки.
5. Добавить локаторы к элементам страницы в отдельном классе файла `locators.py`.
6. Реализовать сам тест-кейс. Назовите тест `test_guest_can_add_product_to_basket`.

Хорошей практикой является создание новой ветки, отходящей от основной, в которой уже будет реализован новый функционал.
Так же рекомендуется сперва создавать структуру, а затем уже переходить к реализации. Например, сперва создаются пустые
файлы и прописываются импорты, затем описываются необходимые локаторы, после чего уже можно переходить к созданию
объекта страницы и методы-проверки, и только в самом конце писать тесты. Но вы можете выполнять шаги с любого пункта.

```python
from selenium.common.exceptions import NoAlertPresentException


def solve_quiz_and_get_code(self):
    alert = self.browser.switch_to.alert
    x = alert.text.split()[2]
    answer = str(math.log(abs((12 * math.sin(float(x))))))
    alert.send_keys(answer)
    alert.accept()
    try:
        alert = self.browser.switch_to.alert
        alert_text = alert.text
        print(f'Code: {alert_text}')
        alert.accept()
    except NoAlertPresentException:
        print('No second alert present')

```

Напомню, чтобы видеть результаты работы функции `print()` необходимо запускать Pytest с флагом `-s`.
