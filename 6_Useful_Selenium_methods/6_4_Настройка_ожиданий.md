# Настройка ожиданий

Разработчики усердно работали над созданием красивых и быстро загружаемых веб-страниц с плавными переходами между ними.
Это было достигнуто за счет использования подхода одностраничных приложений (SPA), когда сайт имеет только
одну страницу, а ее содержимое динамически обновляется с помощью JavaScript, который обменивается информацией с сервером
через REST API.

Хотя этот подход обеспечивает удобство работы с пользователем, он создает проблемы для тех, кто создает UI автотесты.
Непредсказуемое появление или исчезновение элементов на странице, непредсказуемое время рендеринга и
изменение текста в кнопках или сообщениях — вот некоторые особенности приложений SPA, которые необходимо учитывать при
автотестировании. Это один из самых сложных и запутанных аспектов разработки автотестов в Selenium (и других фреймворках
для E-2-E (end-to-end) тестов).

Мы рассмотрим эти распространенные проблемы и узнаем, как их преодолеть.

## Работа методов `get()` и `find_element()`

Резберем тест, проверяющий работу кнопки.

Тестовый сценарий:

1. Открыть страницу http://suninjuly.github.io/wait1.html
2. Нажать на кнопку "Verify"
3. Проверить, что появилась надпись "Verification was successful!"

Страница открывается с помощью метода `.get()`, после чего поиск нужной кнопки осуществляется с помощью одного из
методов `.find_element_by_()`.
Затем для нажатия на кнопку используется метод `.click()`. После этого идентифицируется новый элемент с
определенным текстом, и его текст проверяется на соответствие ожидаемому тексту.

Вот как выглядит код автотеста:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait1.html")

button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

Сначала попытайтесь выполнить тест в ручную, а затем перейдите к автотесту. При выполнении ручного теста вы успешно
завершите тест, но в случае автотеста он завершится ошибкой и сгенерирует сообщение `NoSuchElementException`
для элемента с id="verify". В чем может быть причина этой ошибки?

В Python команды выполняются синхронно, то есть выполняются строго последовательно. Это подразумевает, что пока команда
`get` не будет выполнена, поиск кнопки не начнется. Точно так же, пока кнопка не найдена, на нее нельзя нажать и так
далее.

Однако надежность теста не гарантируется, если веб-страница использует JavaScript (что весьма вероятно на современных
веб-сайтах). Метод `get` ожидает, пока браузер подтвердит загрузку страницы, после чего тест переходит к поиску кнопки.
Однако, если страница является интерактивной, браузер может считать страницу загруженной, в то время как скрипты,
загруженные браузером, продолжают выполняться. Скрипт может управлять внешним видом кнопки на странице и отображать ее с
задержкой, придавая ей плавный вид. В этом случае наш тест завершится ошибкой `NoSuchElementException`,
так как элемент с id="verify" не отображается на странице при выполнении команды
`button = browser.find_element(By.ID, "verify")`.
Эта страница имеет 1-секундную задержку перед появлением кнопки,
и метод `find_element()` попытается найти элемент только один раз, в случае неудачи завершив проверку.

## Фикс с помощью time.sleep()

Поскольку мы знаем о задержке появления кнопки, мы можем ввести паузу перед поиском элемента. Поскольку мы использовали
библиотеку `time` ранее, мы можем использовать ее и здесь.

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait1.html")

time.sleep(1)
button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

Текущее решение добавления фиксированной задержки перед поиском элемента может быть неэффективным при обработке
различных сценариев. Например, если элемент с сообщением тоже появляется с задержкой, или время задержки меняется при
появлении кнопки. Точно так же скорость Интернета на разных машинах может вызывать различия во временном интервале,
когда появляется кнопка. Хотя добавление задержки перед каждым действием может показаться решением, это непрактично, так
как может излишне увеличить время выполнения теста. С увеличением количества тестов эта проблема будет только
усугубляться.

## Фикс с помощью Selenium Waits (Implicit Waits)

Решение с time.sleep() плохое: оно не масштабируемое и трудно поддерживаемое.

Лучший способ справиться с ложными ошибками теста, вызванными асинхронным выполнением сценариев или задержками
сервера, — реализовать решение, которое ожидает появления определенного элемента на странице в течение заданного периода
времени (например, 5 секунд). Мы можем проверять наличие элемента каждые 500 миллисекунд, и как только элемент будет
найден, мы можем сразу перейти к следующему шагу теста. Таким образом, мы можем получить желаемый элемент как можно
скорее в лучшем случае или в течение 5 секунд в худшем случае.

Selenium WebDriver предоставляет особый подход к обработке этого ожидания, который позволяет нам установить ожидание во
время инициализации драйвера и применить его ко всем тестам. Это ожидание называется неявным ожиданием, поскольку нам не
нужно явно указывать его каждый раз, когда мы ищем элементы. Он будет автоматически применяться к каждой последующей
команде.

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
# говорим WebDriver искать каждый элемент в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait1.html")

button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

С неявным ожиданием, установленным во время инициализации драйвера, мы можем гарантировать, что наши тесты останутся
стабильными даже при незначительных задержках на веб-сайте. Для каждого экземпляра команды `find_element` WebDriver
будет ждать до 5 секунд, пока элемент появится на странице, прежде чем вызвать исключение `NoSuchElementException`.
